<html><head><title>Package: iarray</title></head> 
<body>
<center><h1>The "iarray" Package</h1></center>    These routines provide a simple interface to the recursive,
    heirarchical data structure supported in Karma, when only n-dimensional
    data is to be represented.
<p><b>Library:</b> karma
<br><b>Link With:</b> -lkarma
<br><p><a name=iarray></a></table><h4>Functions</h4><table><tr><td><a href=iarray.html#iarray_contour>iarray_contour</a></td><td>Extract contours from a 2-dimensional Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_image_from_multi>iarray_get_image_from_multi</a></td><td>Get an image from a Karma data structure.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_movie_from_multi>iarray_get_movie_from_multi</a></td><td>Get a movie from a Karma data structure.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_nD_from_multi>iarray_get_nD_from_multi</a></td><td>Get a n-dimensional array from a Karma data structure.
</td></tr>
<tr><td><a href=iarray.html#iarray_read_nD>iarray_read_nD</a></td><td>Read in a Karma arrayfile and yield an "Intelligent Array".
</td></tr>
<tr><td><a href=iarray.html#iarray_write>iarray_write</a></td><td>Write an "Intelligent Array" in the Karma data format.
</td></tr>
<tr><td><a href=iarray.html#iarray_create>iarray_create</a></td><td>Create an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_create2>iarray_create2</a></td><td>Create an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_from_multi_array>iarray_get_from_multi_array</a></td><td>Create an Intelligent Array from a Karma data structure.
</td></tr>
<tr><td><a href=iarray.html#iarray_create_from_array_desc>iarray_create_from_array_desc</a></td><td>Create an Intelligent Array from a preallocated nD array.
</td></tr>
<tr><td><a href=iarray.html#iarray_dealloc>iarray_dealloc</a></td><td>Deallocate an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_dealloc2>iarray_dealloc2</a></td><td>Deallocate an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_put_named_value>iarray_put_named_value</a></td><td>Attach a data value to an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_put_named_string>iarray_put_named_string</a></td><td>Attach a string to an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_named_value>iarray_get_named_value</a></td><td>Get attached data from an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_named_string>iarray_get_named_string</a></td><td>Get attached string from an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_sub_array_2D>iarray_get_sub_array_2D</a></td><td>Create a 2-dimensional alias Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_2D_slice_from_3D>iarray_get_2D_slice_from_3D</a></td><td>Create a 2-dimensional Intelligent Array alias from a slice.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_sub_array_3D>iarray_get_sub_array_3D</a></td><td>Create a 3-dimensional alias Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_3D_slice_from_4D>iarray_get_3D_slice_from_4D</a></td><td>Create a 3-dimensional Intelligent Array alias from a slice.
</td></tr>
<tr><td><a href=iarray.html#iarray_remap_torus>iarray_remap_torus</a></td><td>Remap Intelligent Array into a torus.
</td></tr>
<tr><td><a href=iarray.html#iarray_dim_length>iarray_dim_length</a></td><td>Get length of a dimension in an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_dim_name>iarray_dim_name</a></td><td>Get dimension name in an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_set_world_coords>iarray_set_world_coords</a></td><td>Set the world co-ordinates of an Intelligent Array dimension.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_world_coords>iarray_get_world_coords</a></td><td>Get the world co-ordinates of an Intelligent Array dimension.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_dim_desc>iarray_get_dim_desc</a></td><td>Get a dimension descriptor from an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_restrictions>iarray_get_restrictions</a></td><td>Get restriction information.
</td></tr>
<tr><td><a href=iarray.html#iarray_is_full_array>iarray_is_full_array</a></td><td>Test if iarray is the same size as the underlying array.
</td></tr>
<tr><td><a href=iarray.html#iarray_compare_sizes>iarray_compare_sizes</a></td><td>Compare if two Intelligent Arrays are the same size.
</td></tr>
<tr><td><a href=iarray.html#iarray_copy_data>iarray_copy_data</a></td><td>Copy data between Intelligent Arrays.
</td></tr>
<tr><td><a href=iarray.html#iarray_clear>iarray_clear</a></td><td>Clear (set to zero) an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_fill>iarray_fill</a></td><td>Fill an Intelligent Array with a single value.
</td></tr>
<tr><td><a href=iarray.html#iarray_min_max>iarray_min_max</a></td><td>Determine the minimum and maximum value of an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_scale_and_offset>iarray_scale_and_offset</a></td><td>Scale and offset an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_clip_scale_and_offset>iarray_clip_scale_and_offset</a></td><td>Clip, scale and offset an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_add_and_scale>iarray_add_and_scale</a></td><td>Add Intelligent Arrays and scale.
</td></tr>
<tr><td><a href=iarray.html#iarray_add_and_scale2>iarray_add_and_scale2</a></td><td>Add Intelligent Arrays and scale.
</td></tr>
<tr><td><a href=iarray.html#iarray_sub_and_scale>iarray_sub_and_scale</a></td><td>Subtract Intelligent Arrays and scale.
</td></tr>
<tr><td><a href=iarray.html#iarray_multiply_divide>iarray_multiply_divide</a></td><td>Multiply or divide Intelligent Arrays and scale.
</td></tr>
<tr><td><a href=iarray.html#iarray_compute_histogram>iarray_compute_histogram</a></td><td>Compute a histogram of an "Intelligent Array".
</td></tr>
<tr><td><a href=iarray.html#iarray_sum>iarray_sum</a></td><td>Determine the sum of an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_matrix_multiply>iarray_matrix_multiply</a></td><td>Perform a matrix multiply.
</td></tr>
<tr><td><a href=iarray.html#iarray_dim_index>iarray_dim_index</a></td><td>This routine will find the index of a named dimension.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_data_scaling>iarray_get_data_scaling</a></td><td>Get the scale and offset for data in an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_set_data_scaling>iarray_set_data_scaling</a></td><td>Set the scale and offset for data in an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_data_range>iarray_get_data_range</a></td><td>Get the range of data in an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_set_data_range>iarray_set_data_range</a></td><td>Set the range of data in an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_format_value>iarray_format_value</a></td><td>Format a data value into a string.
</td></tr>
<tr><td><a href=iarray.html#iarray_create_from_template>iarray_create_from_template</a></td><td>Create an Intelligent Array from a template array.
</td></tr>
<tr><td><a href=iarray.html#iarray_create_from_template2>iarray_create_from_template2</a></td><td>Create an Intelligent Array from a template array.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_coordinate>iarray_get_coordinate</a></td><td>Get a co-ordinate along a dimension.
</td></tr>
<tr><td><a href=iarray.html#iarray_set_dim_name>iarray_set_dim_name</a></td><td>Change the name of a dimension of an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_append_history_string>iarray_append_history_string</a></td><td>Add a history string to an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_copy_named_element>iarray_copy_named_element</a></td><td>Copy a named element from one Intelligent Array to another.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_fits_axis>iarray_get_fits_axis</a></td><td>Get the FITS axis number of a dimension.
</td></tr>
<tr><td><a href=iarray.html#iarray_create_and_setup>iarray_create_and_setup</a></td><td>Create an Intelligent Array and setup.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_associated_wcs_astro>iarray_get_associated_wcs_astro</a></td><td>Get the KwcsAstro object associated with an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_set_value_name>iarray_set_value_name</a></td><td>Change the data name of an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_find_centroid>iarray_find_centroid</a></td><td>Find the centroid inside an ellipse.
</td></tr>
<tr><td><a href=iarray.html#iarray_copy_attached>iarray_copy_attached</a></td><td>Copy attached data from one Intelligent Array to another.
</td></tr>
<tr><td><a href=iarray.html#iarray_compare_grids_2D>iarray_compare_grids_2D</a></td><td>Compare if two image slices have the same world co-ordinate grid.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_beam_correction>iarray_get_beam_correction</a></td><td>Get the beam correction for an area in an array.
</td></tr>
<tr><td><a href=iarray.html#iarray_register_data_change>iarray_register_data_change</a></td><td>Notify data for Intelligent Array has changed.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_values>iarray_get_values</a></td><td>Convert Intelligent Array data to double precision complex values
</td></tr>
<tr><td><a href=iarray.html#iarray_moment_compute>iarray_moment_compute</a></td><td>Compute the 0th and 1st moments along the Z axis of a cube.
</td></tr>
<tr><td><a href=iarray.html#iarray_moment_create>iarray_moment_create</a></td><td>Create 2-D arrays to contain computed moment maps.
</td></tr>
<tr><td><a href=iarray.html#iarray_write_mono_ps>iarray_write_mono_ps</a></td><td>Write an Intelligent Array as monochrome PostScript.
</td></tr>
<tr><td><a href=iarray.html#iarray_write_pseudocolour_ps>iarray_write_pseudocolour_ps</a></td><td>Write an Intelligent Array as PseudoColour PostScript.
</td></tr>
<tr><td><a href=iarray.html#iarray_write_rgb_ps>iarray_write_rgb_ps</a></td><td>Write an Intelligent Array as TrueColour PostScript.
</td></tr>
<tr><td><a href=iarray.html#iarray_regrid_2D>iarray_regrid_2D</a></td><td>Regrid an array by iterating over the output array.
</td></tr>
<tr><td><a href=iarray.html#iarray_regrid_3D>iarray_regrid_3D</a></td><td>Regrid an array by iterating over the output array.
</td></tr>
<tr><td><a href=iarray.html#iarray_scroll>iarray_scroll</a></td><td>Scroll an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_rect_to_polar>iarray_rect_to_polar</a></td><td>Transform an image from rectangular to polar co-ordinates.
</td></tr>
<tr><td><a href=iarray.html#iarray_transform_3D>iarray_transform_3D</a></td><td>Transform an array by iterating over the input array.
</td></tr>
<tr><td><a href=iarray.html#iarray_untransform_3D>iarray_untransform_3D</a></td><td>Transform an array by iterating over the output array.
</td></tr>
<tr><td><a href=iarray.html#iarray_create_1D>iarray_create_1D</a></td><td>Create a 1-dimensional Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_create_2D>iarray_create_2D</a></td><td>Create a 2-dimensional Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_create_3D>iarray_create_3D</a></td><td>Create a 3-dimensional Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_create_4D>iarray_create_4D</a></td><td>Create a 4-dimensional Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_create_shm>iarray_create_shm</a></td><td>Create an n-dimensional Intelligent Array in shared memory.
</td></tr>
<tr><td><a href=iarray.html#iarray_put_double>iarray_put_double</a></td><td>Attach a double precision data value to an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_put_float>iarray_put_float</a></td><td>Attach a float data value to an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_put_int>iarray_put_int</a></td><td>Attach an integer data value to an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_double>iarray_get_double</a></td><td>Get attached double float from an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_float>iarray_get_float</a></td><td>Get attached float from an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_get_int>iarray_get_int</a></td><td>Get attached integer from an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_fill_double>iarray_fill_double</a></td><td>Fill an Intelligent Array with a double precision float value.
</td></tr>
<tr><td><a href=iarray.html#iarray_fill_float>iarray_fill_float</a></td><td>Fill an Intelligent Array with a single float value.
</td></tr>
<tr><td><a href=iarray.html#iarray_fill_int>iarray_fill_int</a></td><td>Fill an Intelligent Array with a single integer value.
</td></tr>
<tr><td><a href=iarray.html#iarray_min_max_float>iarray_min_max_float</a></td><td>Determine the minimum and maximum value of an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_min_max_int>iarray_min_max_int</a></td><td>Determine the minimum and maximum value of an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_scale_and_offset_float>iarray_scale_and_offset_float</a></td><td>Scale and offset an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_scale_and_offset_int>iarray_scale_and_offset_int</a></td><td>Scale and offset an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_num_dim>iarray_num_dim</a></td><td>Get number of dimensions in an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_type>iarray_type</a></td><td>Get type of data in an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_value_name>iarray_value_name</a></td><td>Get name of data in an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_register_destroy_func>iarray_register_destroy_func</a></td><td>Register destroy function for an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_multi_array>iarray_multi_array</a></td><td>Get the multi_array for an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_multi_index>iarray_multi_index</a></td><td>Get the index of the Intelligent Array within the multi_array.
</td></tr>
<tr><td><a href=iarray.html#iarray_array_desc>iarray_array_desc</a></td><td>Get the array_desc for an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_arrayp>iarray_arrayp</a></td><td>Get the array_pointer for an Intelligent Array.
</td></tr>
<tr><td><a href=iarray.html#iarray_register_data_change_func>iarray_register_data_change_func</a></td><td>Register data change function for an Intelligent Array.
</td></tr>
</table><h4>Prototype Functions</h4><table><tr><td><a href=iarray.html#iarray_PROTO_destroy_func>iarray_PROTO_destroy_func</a></td><td>Register destruction of an Intelligent Array.
</td></tr>
</table><p><hr><center><h2>Functions</h2></center><hr> <a name=iarray_contour></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>void
 <b>iarray_contour</b><i>    (iarray array, unsigned int num_levels,
		     CONST double *contour_levels,
		     uaddr structure_size, uaddr *buffer_sizes,
		     double **x0_arr, double **y0_arr,
		     double **x1_arr, double **y1_arr,
		     uaddr *num_segments)
</i><br><p>    This routine will extract contours from a 2-dimensional
    Intelligent Array, producing a list of line segments that approximate the
    countours. The co-ordinates of the line segments are in linear world
    co-ordinates.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The array.
<br><li><i>num_levels :</i> 
    The number of contour levels.
<br><li><i>contour_levels :</i> 
    The array of contour levels.
<br><li><i>structure_size :</i> 
    The size (in bytes) of the per-level data structure. The
    calling function is expected to pass pointers to various fields in the
    first structure. The fields are modified.
<br><li><i>buffer_sizes :</i> 
    A pointer to the first co-ordinate buffer size field.
<br><li><i>x0_arr :</i> 
    A pointer to the first x0 co-ordinate array field. The co-ordinate
    array may be internally reallocated.
<br><li><i>y0_arr :</i> 
    A pointer to the first y0 co-ordinate array field. The co-ordinate
    array may be internally reallocated.
<br><li><i>x1_arr :</i> 
    A pointer to the first x1 co-ordinate array field. The co-ordinate
    array may be internally reallocated.
<br><li><i>y1_arr :</i> 
    A pointer to the first y1 co-ordinate array field. The co-ordinate
    array may be internally reallocated.
<br><li><i>num_segments :</i> 
    A pointer to the first number of segments field.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_image_from_multi></a> flag
 <b>iarray_get_image_from_multi</b><i>    (multi_array *multi_desc, iarray *pseudo,
				  iarray *red, iarray *green, iarray *blue,
				  unsigned int *cmap_index)
</i><br><p>    This routine will find an image embedded in a Karma data
    structure. The image may be single-channel (PseudoColour) or it may be a
    TrueColour image (red, green and blue components).
<p><b>Parameters:</b><ul><li><i>multi_desc :</i> 
    The Karma data structure.
<br><li><i>pseudo :</i> 
    If a single-channel image is found, the corresponding Intelligent
    Array is written here. If no single-channel image is found, NULL is written
    here.
<br><li><i>red :</i> 
    If a TrueColour image is found, the red component Intelligent Array
    is written here. If no TrueColour image is found, NULL is written here.
<br><li><i>green :</i> 
    If a TrueColour image is found, the green component Intelligent
    Array is written here. If no TrueColour image is found, NULL is written
    here.
<br><li><i>blue :</i> 
    If a TrueColour image is found, the blue component Intelligent Array
    is written here. If no TrueColour image is found, NULL is written here.
<br><li><i>cmap_index :</i> 
    If the image found is a single-channel image and the data
    structure has an associated RGBcolourmap, the index to the colourmap
    structure is written here. If no colourmap is found, the value written here
    is set to the number of general data structures in multi_desc.
<br></ul><b>Returns:</b>     TRUE on succes, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_movie_from_multi></a> flag
 <b>iarray_get_movie_from_multi</b><i>    (multi_array *multi_desc, iarray *pseudo,
				  iarray *red, iarray *green, iarray *blue,
				  unsigned int *cmap_index)
</i><br><p>    This routine will find a movie embedded in a Karma data
    structure. The movie may be single-channel (PseudoColour) or it may be a
    TrueColour movie (red, green and blue components).
<p><b>Parameters:</b><ul><li><i>multi_desc :</i> 
    The Karma data structure.
<br><li><i>pseudo :</i> 
    If a single-channel movie is found, the corresponding Intelligent
    Array is written here. If no single-channel movie is found, NULL is written
    here.
<br><li><i>red :</i> 
    If a TrueColour movie is found, the red component Intelligent Array
    is written here. If no TrueColour movie is found, NULL is written here.
<br><li><i>green :</i> 
    If a TrueColour movie is found, the green component Intelligent
    Array is written here. If no TrueColour movie is found, NULL is written
    here.
<br><li><i>blue :</i> 
    If a TrueColour movie is found, the blue component Intelligent Array
    is written here. If no TrueColour movie is found, NULL is written here.
<br><li><i>cmap_index :</i> 
    If the movie found is a single-channel movie and the data
    structure has an associated RGBcolourmap, the index to the colourmap
    structure is written here. If no colourmap is found, the value written here
    is set to the number of general data structures in multi_desc.
<br></ul><b>Returns:</b>     TRUE on succes, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_nD_from_multi></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_get_nD_from_multi</b><i>    (multi_array *multi_desc, CONST char *name,
			       unsigned int num_dim, iarray *pseudo,
			       iarray *red, iarray *green, iarray *blue,
			       unsigned int *cmap_index)
</i><br><p>    This routine will find an array embedded in a Karma data
    structure. The array may be single-channel (PseudoColour) or it may be a
    TrueColour array (red, green and blue components).
<p><b>Parameters:</b><ul><li><i>multi_desc :</i> 
    The Karma data structure.
<br><li><i>name :</i> 
    The name of the general data structure. This may be NULL.
<br><li><i>pseudo :</i> 
    If a single-channel movie is found, the corresponding Intelligent
    Array is written here. If no single-channel movie is found, NULL is written
    here.
<br><li><i>num_dim :</i> 
    The number of dimensions the array must have. Passing 0 will
    cause the programme to abort.
<br><li><i>red :</i> 
    If a TrueColour array is found, the red component Intelligent Array
    is written here. If no TrueColour array is found, NULL is written here.
<br><li><i>green :</i> 
    If a TrueColour array is found, the green component Intelligent
    Array is written here. If no TrueColour array is found, NULL is written
    here.
<br><li><i>blue :</i> 
    If a TrueColour array is found, the blue component Intelligent Array
    is written here. If no TrueColour array is found, NULL is written here.
<br><li><i>cmap_index :</i> 
    If the array found is a single-channel array and the data
    structure has an associated RGBcolourmap, the index to the colourmap
    structure is written here. If no colourmap is found, the value written here
    is set to the number of general data structures in multi_desc.
<br></ul><b>Returns:</b>     TRUE on succes, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_read_nD></a> iarray
 <b>iarray_read_nD</b><i>    (CONST char *object, flag cache, CONST char *arrayname,
		       unsigned int num_dim, CONST char **dim_names,
		       CONST char *elem_name,
		       unsigned int mmap_option)
</i><br><p>    Read in a Karma arrayfile and yield an "Intelligent Array".
<p><b>Parameters:</b><ul><li><i>object :</i> 
    The name of the arrayfile to read. This parameter is passed
    directly to the <a href=dsxfr.html#dsxfr_get_multi>dsxfr_get_multi</a> routine. In order to understand the
    operation of this routine, the operation of the <a href=dsxfr.html#dsxfr_get_multi>dsxfr_get_multi</a> routine
    must be understood.
<br><li><i>cache :</i> 
    This is passed directly to the <a href=dsxfr.html#dsxfr_get_multi>dsxfr_get_multi</a> routine.
    This controls whether disc arrayfiles are cached in memory for later use.
<br><li><i>arrayname :</i> 
    The name of the general data structure in the arrayfile to
    search for. If this is NULL, the routine searches for the default name
    "Intelligent Array". If the arrayfile has only one general data structure,
    then this parameter is ignored.
<br><li><i>num_dim :</i> 
    The routine searches for an n-dimensional array with a single
    atomic element at each point in multi-dimensional space. If this parameter
    is greater than 0, the routine will only return an array with the specified
    number of dimensions. If the value is 0, then the routine will return an
    n-dimensional array.
<br><li><i>dim_names :</i> 
    If <em>num_dim</em> is not 0, then if this parameter is NULL, the
    routine will search for and return an array with the default dimension
    names (see <a href=iarray.html#iarray_create>iarray_create</a> for a list of these) if more than one
    n-dimensional, single element array exists in the general data structure,
    or the only n-dimensional array with the specified number of dimensions.
    If the routine can't find an adequate default, it will not return an array.
    If <em>num_dim</em> is not 0, and this parameter points to an array of strings,
    then the routine will only return an array which matches the specified
    dimension names. The first name in the array of strings must be the highest
    order dimension.
<br><li><i>elem_name :</i> 
    If this is NULL, the routine will ignore the element name of
    the array which is located, else it will insist on the array element name
    matching the specified name.
<br><li><i>mmap_option :</i> 
    This is passed directly to the <a href=dsxfr.html#dsxfr_get_multi>dsxfr_get_multi</a> routine.
    This parameter controls the memory mapping of disc arrayfiles.
    If the data structure is likely to be subsequently modified, the value must
    be K_CH_MAP_NEVER, otherwise the data may be read-only memory mapped
    and writing to it will cause a segmentation fault.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else an
    error message is printed to the standard output and NULL is returned.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_write></a> flag
 <b>iarray_write</b><i>    (iarray array, CONST char *arrayfile)
</i><br><p>    Write an "Intelligent Array" in the Karma data format.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The "Intelligent Array".
<br><li><i>arrayfile :</i> 
    The name of the arrayfile to write. See <a href=dsxfr.html#dsxfr_put_multi>dsxfr_put_multi</a> for
    details on the interpretation of this.
<br></ul><b>Returns:</b>     TRUE on success, else an error message is printed to the standard
    output and FALSE is returned.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_create></a> iarray
 <b>iarray_create</b><i>    (unsigned int type, unsigned int num_dim,
		      CONST char **dim_names, CONST unsigned long *dim_lengths,
		      CONST char *elem_name, iarray old_array)
</i><br><p>    This routine will create an "Intelligent Array", using the Karma
    general data structure format as the underlying data format.
    If the environment variable "IARRAY_ALLOC_DEBUG" is set to "TRUE" then the
    routine will print allocation debugging information.
<p><b>Parameters:</b><ul><li><i>type :</i> 
    The desired type of the data elements. See <a href=ds.html#ds_KARMA_DATA_TYPES>ds_KARMA_DATA_TYPES</a>
    for a list of defined data types.
<br><li><i>num_dim :</i> 
    The number of dimensions the array must have.
<br><li><i>dim_names :</i> 
    The names of the dimensions. If this is NULL, the default names
    "Axis 0", "Axis 1", etc. are used.
<br><li><i>dim_lengths :</i> 
    The lengths of the dimensions. The first entry in this array
    and the <em>dim_names</em> array refers to the most significant dimension
    (i.e. the dimension with the greatest stride in memory).
<br><li><i>elem_name :</i> 
    The name of the element. If this is NULL, the default name
    "Data Value" is choosen.
<br><li><i>old_array :</i> 
    Any auxilary information not representable with "Intelligent
    Arrays" which is to be included in the Karma data format is copied from
    here. If this is NULL, no auxilary information is copied.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else an
    error message is printed to the standard output and NULL is returned.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_create2></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>iarray
 <b>iarray_create2</b><i>    (unsigned int type, unsigned int num_dim,
		       CONST char **dim_names,CONST unsigned long *dim_lengths,
		       CONST char *elem_name, iarray old_array, flag clear)
</i><br><p>    This routine will create an "Intelligent Array", using the Karma
    general data structure format as the underlying data format.
    If the environment variable "IARRAY_ALLOC_DEBUG" is set to "TRUE" then the
    routine will print allocation debugging information.
<p><b>Parameters:</b><ul><li><i>type :</i> 
    The desired type of the data elements. See <a href=ds.html#ds_KARMA_DATA_TYPES>ds_KARMA_DATA_TYPES</a>
    for a list of defined data types.
<br><li><i>num_dim :</i> 
    The number of dimensions the array must have.
<br><li><i>dim_names :</i> 
    The names of the dimensions. If this is NULL, the default names
    "Axis 0", "Axis 1", etc. are used.
<br><li><i>dim_lengths :</i> 
    The lengths of the dimensions. The first entry in this array
    and the <em>dim_names</em> array refers to the most significant dimension
    (i.e. the dimension with the greatest stride in memory).
<br><li><i>elem_name :</i> 
    The name of the element. If this is NULL, the default name
    "Data Value" is choosen.
<br><li><i>old_array :</i> 
    Any auxilary information not representable with "Intelligent
    Arrays" which is to be included in the Karma data format is copied from
    here. If this is NULL, no auxilary information is copied.
<br><li><i>clear :</i> 
    If TRUE, the array is filled with zeros, otherwise the contents
    will be random.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else an
    error message is printed to the standard output and NULL is returned.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_from_multi_array></a> iarray
 <b>iarray_get_from_multi_array</b><i>    (multi_array *multi_desc,
				    CONST char *arrayname,
				    unsigned int num_dim,
				    CONST char **dim_names,
				    CONST char *elem_name)
</i><br><p>    This routine will yield an "Intelligent Array" from a multi array
    Karma general data structure. The routine searches for a n-dimensional
    array with a single atomic element at each point in multi-dimensional space
<p><b>Parameters:</b><ul><li><i>multi_desc :</i> 
    The multi array header pointer. The attachment count is
    incremented on successful completion of this routine.
<br><li><i>arrayname :</i> 
    The name of the general data structure in the arrayfile to
    search for. If this is NULL, the routine searches for the default name
    "Intelligent Array", and if that is not found, the first general data
    structure is used. If the arrayfile has only one general data structure,
    then this parameter is ignored.
<br><li><i>num_dim :</i> 
    If greater than 0, the routine will only return an array with
    this many dimensions. If 0, then the routine will return an n-dimensional
    array.
<br><li><i>dim_names :</i> 
    If <em>num_dim</em> is not 0, then if this NULL, the routine will
    search for and return an array with the default dimension names (see
    <em>iarray_create</em> for a list of these) if more than one n-dimensional,
    single element array exists in the general data structure, or the only
    n-dimensional array with the specified number of dimensions. If the routine
    can't find an adequate default, it will not return an array. If <em>num_dim</em>
    is not 0, and this points to an array of strings, then the routine will
    only return an array which matches the specified dimension names. The first
    name in the array of strings must be the highest order dimension.
<br><li><i>elem_name :</i> 
    If NULL, the routine will ignore the element name of the array
    which is located, else it will insist on the array element name matching
    this name.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else an
    error message is printed to the standard output and NULL is returned.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_create_from_array_desc></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>iarray
 <b>iarray_create_from_array_desc</b><i>    (array_desc *arr_desc,
				      CONST array_pointer *arrayp,
				      unsigned int elem_index)
</i><br><p>    Create an Intelligent Array from a preallocated nD array.
<p><b>Parameters:</b><ul><li><i>arr_desc :</i> 
    The array descriptor. This may be modified.
<br><li><i>arrayp :</i> 
    The array data pointer. If this is NULL the array data is
    internally allocated.
<br><li><i>elem_index :</i> 
    The index of the element in the array packet descriptor.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else an
    error message is printed to the standard output and NULL is returned.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_dealloc></a> void
 <b>iarray_dealloc</b><i>    (iarray array)
</i><br><p>    This routine will deallocate an "Intelligent Array". If the
    environment variable "IARRAY_ALLOC_DEBUG" is set to "TRUE" then the routine
    will print deallocation debugging information.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_dealloc2></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>void
 <b>iarray_dealloc2</b><i>    (iarray array)
</i><br><p>    This routine will deallocate an "Intelligent Array". If the
    environment variable "IARRAY_ALLOC_DEBUG" is set to "TRUE" then the routine
    will print deallocation debugging information.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array. If this is NULL, nothing is done.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_put_named_value></a> flag
 <b>iarray_put_named_value</b><i>    (iarray array, CONST char *name, unsigned int type,
			     double value[2])
</i><br><p>    This routine will add a unique named value to the underlying
    Karma general data structure of an "Intelligent Array".
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>name :</i> 
    The name of the element to add.
<br><li><i>type :</i> 
    The type of the data which is to be written.
<br><li><i>value :</i> 
    The value of the data.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_put_named_string></a> flag
 <b>iarray_put_named_string</b><i>    (iarray array, CONST char *name,
			      CONST char *string)
</i><br><p>    This routine will addor update a unique named string to the
    underlying Karma general data structure of an "Intelligent Array".
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>name :</i> 
    The name of the element to add.
<br><li><i>string :</i> 
    The string data.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_named_value></a> flag
 <b>iarray_get_named_value</b><i>    (iarray array, CONST char *name,
			     unsigned int *type, double value[2])
</i><br><p>    This routine will get a unique named value from the underlying
    Karma general data structure of an "Intelligent Array".
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>name :</i> 
    The name of the element.
<br><li><i>type :</i> 
    The type of the input data found will be written here. If this is
    NULL, nothing is written here.
<br><li><i>value :</i> 
    The value of the converted data will be written here.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_named_string></a> char *
 <b>iarray_get_named_string</b><i>    (iarray array, CONST char *name)
</i><br><p>    This routine will get a unique named string from the underlying
    Karma general data structure of an "Intelligent Array".
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>name :</i> 
    The name of the element.
<br></ul><b>Returns:</b>     A pointer to a dynamically allocated copy of the string on
    success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_sub_array_2D></a> iarray
 <b>iarray_get_sub_array_2D</b><i>    (iarray array, int starty, int startx,
				unsigned int ylen, unsigned int xlen)
</i><br><p>    This routine will create an "Intelligent Array" which is an alias
    or a sub-array of another "Intelligent Array". Subsequent modification of
    the alias array will modify the data of the original array. Sub-arrays may
    be created from other sub-arrays. The attachment count of the underlying
    <em>multi_array</em> data structure is incremented on successful completion.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The original array.
<br><li><i>starty :</i> 
    The starting y (row) index in the original array corresponding to
    the first row of the alias array.
<br><li><i>startx :</i> 
    The starting x (column) index in the original array corresponding
    to the first column of the alias array.
<br><li><i>ylen :</i> 
    The number of y co-ordinates (rows) in the alias array.
<br><li><i>xlen :</i> 
    The number of x co-ordinates (columns) in the alias array.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     Sub-arrays cannot be saved to disc.
</ul><p><hr> <a name=iarray_get_2D_slice_from_3D></a> iarray
 <b>iarray_get_2D_slice_from_3D</b><i>    (iarray cube, unsigned int ydim,
				    unsigned int xdim, unsigned int slice_pos)
</i><br><p>    This routine will create a 2-D "Intelligent Array" which is an
    alias of an arbitrary slice of a 3-D array.
<p><b>Parameters:</b><ul><li><i>cube :</i> 
    The input 3-D array.
<br><li><i>ydim :</i> 
    The dimension in the 3-D array which will become the y dimension
    (most significant) of the output array.
<br><li><i>xdim :</i> 
    The dimension in the 3-D array which will become the x dimension
    (least significant) of the output array.
<br><li><i>slice_pos :</i> 
    The position of the slice along the unspecified (remaining)
    dimension in the 3-D array.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     Alias arrays cannot be saved to disc.
</ul><p><hr> <a name=iarray_get_sub_array_3D></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>iarray
 <b>iarray_get_sub_array_3D</b><i>    (iarray array,
				int startz, int starty, int startx,
				unsigned int zlen, unsigned int ylen,
				unsigned int xlen)
</i><br><p>    This routine will create an "Intelligent Array" which is an alias
    or a sub-array of another "Intelligent Array". Subsequent modification of
    the alias array will modify the data of the original array. Sub-arrays may
    be created from other sub-arrays. The attachment count of the underlying
    <em>multi_array</em> data structure is incremented on successful completion.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The original array.
<br><li><i>startz :</i> 
    The starting z (plane) index in the original array corresponding
    to the first plane of the alias array.
<br><li><i>starty :</i> 
    The starting y (row) index in the original array corresponding to
    the first row of the alias array.
<br><li><i>startx :</i> 
    The starting x (column) index in the original array corresponding
    to the first column of the alias array.
<br><li><i>zlen :</i> 
    The number of z co-ordinates (planes) in the alias array.
<br><li><i>ylen :</i> 
    The number of y co-ordinates (rows) in the alias array.
<br><li><i>xlen :</i> 
    The number of x co-ordinates (columns) in the alias array.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     Sub-arrays cannot be saved to disc.
</ul><p><hr> <a name=iarray_get_3D_slice_from_4D></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>iarray
 <b>iarray_get_3D_slice_from_4D</b><i>    (iarray hcube, unsigned int zdim,
				    unsigned int ydim, unsigned int xdim,
				    unsigned int cube_pos)
</i><br><p>    This routine will create a 3-D "Intelligent Array" which is an
    alias of an arbitrary slice of a 4-D array.
<p><b>Parameters:</b><ul><li><i>hcube :</i> 
    The input 4-D array.
<br><li><i>zdim :</i> 
    The dimension in the 4-D array which will become the z dimension
    (most significant) of the output array.
<br><li><i>ydim :</i> 
    The dimension in the 4-D array which will become the y dimension
    of the output array.
<br><li><i>xdim :</i> 
    The dimension in the 4-D array which will become the x dimension
    (least significant) of the output array.
<br><li><i>cube_pos :</i> 
    The position of the slice along the unspecified (remaining)
    dimension in the 4-D array.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     Alias arrays cannot be saved to disc.
</ul><p><hr> <a name=iarray_remap_torus></a> void
 <b>iarray_remap_torus</b><i>    (iarray array, unsigned int boundary_width)
</i><br><p>    This routine will remap an N-dimensional "Intelligent Array" to a
    pseudo-toroidal array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>boundary_width :</i> 
    The width of the array boundary within which the array
    appears to be toroidal.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_dim_length></a> unsigned long
 <b>iarray_dim_length</b><i>    (iarray array, unsigned int index)
</i><br><p>    Get length of a dimension in an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>index :</i> 
    The index of the dimension.
<br></ul><b>Returns:</b>     The length of the specified dimension.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_dim_name></a> CONST char *
 <b>iarray_dim_name</b><i>    (iarray array, unsigned int index)
</i><br><p>    This routine will get the name of a specified dimension in a
    simple, n-dimensional array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>index :</i> 
    The index of the dimension.
<br></ul><b>Returns:</b>     A pointer to the name of the specified dimension.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_set_world_coords></a> void
 <b>iarray_set_world_coords</b><i>    (iarray array, unsigned int index, double first,
			      double last)
</i><br><p>    Set the world co-ordinates of an Intelligent Array dimension.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>index :</i> 
    The index of the dimension.
<br><li><i>first :</i> 
    The first real world co-ordinate.
<br><li><i>last :</i> 
    The last real world co-ordinate.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_world_coords></a> void
 <b>iarray_get_world_coords</b><i>    (iarray array, unsigned int index,
			      double *first, double *last)
</i><br><p>    Get the world co-ordinates of an Intelligent Array dimension.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>index :</i> 
    The index of the dimension.
<br><li><i>first :</i> 
    The first real world co-ordinate is written here.
<br><li><i>last :</i> 
    The last real world co-ordinate is written here.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_dim_desc></a> dim_desc *
 <b>iarray_get_dim_desc</b><i>    (iarray array, unsigned int index)
</i><br><p>    Get a dimension descriptor from an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>index :</i> 
    The index of the dimension.
<br></ul><b>Returns:</b>     A pointer to the dimension descriptor.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_restrictions></a> unsigned int
 <b>iarray_get_restrictions</b><i>    (iarray array, char ***restr_names,
				      double **restr_values)
</i><br><p>    This routine will get any associated restrictions for an
    Intelligent Array. The routine will dynamically allocate space for the
    restriction data, which must be externally freed.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>restr_names :</i> 
    The array of pointers to restrictions names will be written
    here.
<br><li><i>restr_values :</i> 
    The array of restriction values will be written here.
<br></ul><b>Returns:</b>     The number of restrictions. This may be 0.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_is_full_array></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_is_full_array</b><i>    (iarray array, flag *all_contiguous)
</i><br><p>    This routine will test if an Intelligent Array is the same size
    and dimensionality as the underlying array descriptor.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>all_contiguous :</i> 
    TRUE is written here if all dimensions are contiguous,
    else FALSE is written here. This may be NULL. Nothing is written here if
    the array is not full size.
<br></ul><b>Returns:</b>     TRUE if the Intelligent Array is the same size, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_compare_sizes></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_compare_sizes</b><i>    (iarray array1, iarray array2, flag message)
</i><br><p>    Compare if two Intelligent Arrays are the same size.
<p><b>Parameters:</b><ul><li><i>array1 :</i> 
    One of the Intelligent Arrays to compare.
<br><li><i>array2 :</i> 
    The other Intelligent Array to compare.
<br><li><i>message :</i> 
    If TRUE, explanatory messages are displayed.
<br></ul><b>Returns:</b>     TRUE of the number of dimensions and dimension lengths are the
    same, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_copy_data></a> flag
 <b>iarray_copy_data</b><i>    (iarray output, iarray input, flag magnitude)
</i><br><p>    This routine will copy data from one "Intelligent Array" to
    another. The sizes of the two arrays must be identical.
    The routine can deal with the types of the two arrays being different
<p><b>Parameters:</b><ul><li><i>output :</i> 
    The output Intelligent Array.
<br><li><i>input :</i> 
    The input Intelligent Array.
<br><li><i>magnitude :</i> 
    If TRUE then when converting from a complex array to a real
    array, the magnitude of the complex data is taken, else the real component
    is copied.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     When converting from a real array to a complex data array, the
    imaginary components are set to zero.
</ul><p><hr> <a name=iarray_clear></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_clear</b><i>    (iarray array)
</i><br><p>    Clear (set to zero) an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_fill></a> flag
 <b>iarray_fill</b><i>    (iarray array, double value[2])
</i><br><p>    Fill an Intelligent Array with a single value.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>value :</i> 
    The fill value.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_min_max></a> flag
 <b>iarray_min_max</b><i>    (iarray array, unsigned int conv_type, double *min,
		     double *max)
</i><br><p>    Determine the minimum and maximum value of an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>conv_type :</i> 
    The conversion type to use for complex numbers. This is ignored
    if the array is not complex. See <a href=ds.html#ds_COMPLEX_CONVERSIONS>ds_COMPLEX_CONVERSIONS</a> for legal
    values.
<br><li><i>min :</i> 
    The routine will write the minimum value here.
<br><li><i>max :</i> 
    The routine will write the maximum value here.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe.
<br><p><hr> <a name=iarray_scale_and_offset></a> flag
 <b>iarray_scale_and_offset</b><i>    (iarray out, iarray inp, double scale[2],
			      double offset[2], flag magnitude)
</i><br><p>    This routine will perform a scale and offset on every element in
    an "Intelligent Array" (output = input * scale + offset).
<p><b>Parameters:</b><ul><li><i>out :</i> 
    The output Intelligent Array.
<br><li><i>inp :</i> 
    The input Intelligent Array.
<br><li><i>scale :</i> 
    The complex scale value.
<br><li><i>offset :</i> 
    The complex offset value.
<br><li><i>magnitude :</i> 
    If TRUE and converting from a complex to a real array, the
    magnitude of the complex data (after scale and offset have been applied) is
    used, else the real component of the complex scaled data is used.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The input and output arrays MUST be the same size (though not
    necessarily the same type).
<li>     When converting from a real to a complex array, the imaginary
    component of the output array is set to 0. A complex scale or offset value
    will not result in a complex output if the input is real.
</ul><p><hr> <a name=iarray_clip_scale_and_offset></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_clip_scale_and_offset</b><i>    (iarray out, iarray inp, double scale,
				   double offset,
				   double lower_clip, double upper_clip,
				   flag blank)
</i><br><p>    This routine will perform a clipping operation followed by a
    scale and offset on every element in  an "Intelligent Array". The operation
    following the clipping is: (output = input * scale + offset).
<p><b>Parameters:</b><ul><li><i>out :</i> 
    The output Intelligent Array.
<br><li><i>inp :</i> 
    The input Intelligent Array.
<br><li><i>scale :</i> 
    The scale value.
<br><li><i>offset :</i> 
    The offset value.
<br><li><i>lower_clip :</i> 
    The input data is clipped so that no value is below this.
<br><li><i>upper_clip :</i> 
    The input data is clipped so that no value is above this.
<br><li><i>blank :</i> 
    If TRUE, clipped values are blanked.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The input and output arrays MUST be the same size (though not
    necessarily the same type). Both arrays must be real.
</ul><p><hr> <a name=iarray_add_and_scale></a> flag
 <b>iarray_add_and_scale</b><i>    (iarray out, iarray inp1, iarray inp2,
			   double scale[2], flag magnitude)
</i><br><p>    This routine will add two "Intelligent Array" to each other and
    scales the result. The sizes of the two input arrays and the output must be
    identical.
    The routine performs the following computation:
    OUT = INP1 + INP2 * scale
    The routine will automatically perform type conversions if necessary.
<p><b>Parameters:</b><ul><li><i>out :</i> 
    The output Intelligent Array.
<br><li><i>inp1 :</i> 
    The first input Intelligent Array.
<br><li><i>inp2 :</i> 
    The second input Intelligent Array.
<br><li><i>scale :</i> 
    The complex scale value.
<br><li><i>magnitude :</i> 
    If TRUE then when converting from a complex to a real data
    type, the magnitude is taken, else the real component is copied.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     When converting from a real to a complex data type, the imaginary
    component is set to zero.
</ul><p><hr> <a name=iarray_add_and_scale2></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_add_and_scale2</b><i>    (iarray out, iarray inp1, iarray inp2,
			    double scale[2], double offset[2], flag magnitude)
</i><br><p>    This routine will add two "Intelligent Array" to each other and
    scales the result. The sizes of the two input arrays and the output must be
    identical.
    The routine performs the following computation:
    OUT = INP1 + INP2 * scale + offset
    The routine will automatically perform type conversions if necessary.
<p><b>Parameters:</b><ul><li><i>out :</i> 
    The output Intelligent Array.
<br><li><i>inp1 :</i> 
    The first input Intelligent Array.
<br><li><i>inp2 :</i> 
    The second input Intelligent Array.
<br><li><i>scale :</i> 
    The complex scale value.
<br><li><i>offset :</i> 
    The complex offset value.
<br><li><i>magnitude :</i> 
    If TRUE then when converting from a complex to a real data
    type, the magnitude is taken, else the real component is copied.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     When converting from a real to a complex data type, the imaginary
    component is set to zero.
</ul><p><hr> <a name=iarray_sub_and_scale></a> flag
 <b>iarray_sub_and_scale</b><i>    (iarray out, iarray inp1, iarray inp2,
			   double scale[2], flag magnitude)
</i><br><p>    This routine will subtract two "Intelligent Array" from each
    other and scales the result. The sizes of the two input arrays and the
    output must be identical.
    The routine performs the following computation:
    OUT = INP1 - INP2 * scale
    The routine will automatically perform type conversions if necessary.
<p><b>Parameters:</b><ul><li><i>out :</i> 
    The output Intelligent Array.
<br><li><i>inp1 :</i> 
    The first input Intelligent Array.
<br><li><i>inp2 :</i> 
    The second input Intelligent Array.
<br><li><i>scale :</i> 
    The complex scale value.
<br><li><i>magnitude :</i> 
    If TRUE then when converting from a complex to a real data
    type, the magnitude is taken, else the real component is copied.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     When converting from a real to a complex data type, the imaginary
    component is set to zero.
</ul><p><hr> <a name=iarray_multiply_divide></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_multiply_divide</b><i>    (iarray out, iarray inp1, iarray inp2,
			     flag multiply, double scale[2], double offset[2],
			     flag magnitude)
</i><br><p>    This routine will add two "Intelligent Array" to each other and
    scales the result. The sizes of the two input arrays and the output must be
    identical.
    The routine performs the following computation:
    OUT = INP1 op (INP2 * scale + offset)
    where <em>op</em> is the multiply or divide operation.
    The routine will automatically perform type conversions if necessary.
<p><b>Parameters:</b><ul><li><i>out :</i> 
    The output Intelligent Array.
<br><li><i>inp1 :</i> 
    The first input Intelligent Array.
<br><li><i>inp2 :</i> 
    The second input Intelligent Array.
<br><li><i>scale :</i> 
    The complex scale value.
<br><li><i>offset :</i> 
    The complex offset value.
<br><li><i>magnitude :</i> 
    If TRUE then when converting from a complex to a real data
    type, the magnitude is taken, else the real component is copied.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     When converting from a real to a complex data type, the imaginary
    component is set to zero.
</ul><p><hr> <a name=iarray_compute_histogram></a> flag
 <b>iarray_compute_histogram</b><i>    (iarray array, unsigned int conv_type,
			       double min, double max, unsigned long num_bins,
			       unsigned long *histogram_array,
			       unsigned long *histogram_peak,
			       unsigned long *histogram_mode)
</i><br><p>    Compute a histogram of an "Intelligent Array".
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The array.
<br><li><i>conv_type :</i> 
    The conversion type to use for complex numbers. See
    <a href=ds.html#ds_COMPLEX_CONVERSIONS>ds_COMPLEX_CONVERSIONS</a> for legal values. CONV_CtoR_ENVELOPE is not
    legal.
<br><li><i>min :</i> 
    Data values below this will be ignored.
<br><li><i>max :</i> 
    Data values above this will be ignored.
<br><li><i>num_bins :</i> 
    The number of histogram bins.
<br><li><i>histogram_array :</i> 
    A pointer to the histogram array. The values in this
    array are updated, and hence must be initialised externally.
<br><li><i>histogram_peak :</i> 
    The peak of the histogram is written here. This value is
    updated, and hence must be externally initialised to 0.
<br><li><i>histogram_mode :</i> 
    The mode of the histogram (index value of the peak) will
    be written here. This value is updated, and hence must be externally
    initialised to 0.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe.
<br><p><hr> <a name=iarray_sum></a> flag
 <b>iarray_sum</b><i>    (iarray array, double sum[2])
</i><br><p>    Determine the sum of an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>sum :</i> 
    The routine will write the sum here.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe.
<br><p><hr> <a name=iarray_matrix_multiply></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_matrix_multiply</b><i>    (iarray out, iarray in1, iarray in2, flag thread)
</i><br><p>    Perform a matrix multiply.
<p><b>Parameters:</b><ul><li><i>out :</i> 
    The output array (matrix).
<br><li><i>in1 :</i> 
    The first input array.
<br><li><i>in2 :</i> 
    The second input array.
<br><li><i>thread :</i> 
    If TRUE, the operation may be threaded, else it will not be.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe.
<br><b>Note:</b><ul> <li>     Only double precision arrays are supported.
</ul><p><hr> <a name=iarray_dim_index></a> unsigned int
 <b>iarray_dim_index</b><i>    (iarray array, CONST char *name)
</i><br><p>    This routine will find the index of a named dimension.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The array.
<br><li><i>name :</i> 
    The name of the dimension.
<br></ul><b>Returns:</b>     The dimension index if found, else the number of dimension in the
    array is returned.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_data_scaling></a> flag
 <b>iarray_get_data_scaling</b><i>    (iarray array, double *scale, double *offset)
</i><br><p>    This routine will determine the scale and offset for data in an
    Intelligent Array. This may be important when a floating-point array has
    been converted to an integer array to save space. Scaling information
    should be attached to the array so that the original data values may be
    reconstructed (aside from quantisation effects). The following expression
    may be used to convert scaled values to real values:
    (output = input * scale + offset). The scaling and offset values should
    previously have been attached to the Intelligent Array using the
    <a href=iarray.html#iarray_set_data_scaling>iarray_set_data_scaling</a> routine.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The array.
<br><li><i>scale :</i> 
    The scaling value will be written here. The name of the scaling
    value is constructed by appending "__SCALE" to the array value name (see
    <a href=iarray.html#iarray_value_name>iarray_value_name</a>). If no scaling value is found, 1.0 is written
    here. As a fallback, if the FITS-style "BSCALE" keyword is found and is
    appropriate, this is used.
<br><li><i>offset :</i> 
    The offset value will be written here. The name of the offset
    value is constructed by appending "__OFFSET" to the array value name (see
    <a href=iarray.html#iarray_value_name>iarray_value_name</a>). If no offset value is found, 0.0 is written
    here. As a fallback, if the FITS-style "BZERO" keyword is found and is
    appropriate, this is used.
<br></ul><b>Returns:</b>     TRUE if either the scaling or offset value were found, else FALSE
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_set_data_scaling></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_set_data_scaling</b><i>    (iarray array, double scale, double offset)
</i><br><p>    This routine will set the scale and offset for data in an
    Intelligent Array. This may be important when a floating-point array has
    been converted to an integer array to save space. The scaling information
    will be attached to the array so that the original data values may be
    reconstructed (aside from quantisation effects). The following expression
    may be used to convert scaled values to real values:
    (output = input * scale + offset).
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The array.
<br><li><i>scale :</i> 
    The scaling value. The name of the scaling value is constructed by
    appending "__SCALE" to the array value name (see <a href=iarray.html#iarray_value_name>iarray_value_name</a>)
    If appropriate, the FITS-style "BSCALE" keyword is written instead.
<br><li><i>offset :</i> 
    The offset value. The name of the offset value is constructed by
    appending "__OFFSET" to the array value name(see <a href=iarray.html#iarray_value_name>iarray_value_name</a>)
    If appropriate, the FITS-style "BZERO" keyword is written instead.
<br></ul><b>Returns:</b>     TRUE if the scaling information is different from what was
    already attached to the array, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_data_range></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_get_data_range</b><i>    (iarray array, double *minimum, double *maximum)
</i><br><p>    This routine will determine the range of data in an Intelligent
    Array. Range information should be attached to the header.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The array.
<br><li><i>minimum :</i> 
    The minimum value will be written here. The name of the minimum
    value is constructed by appending "__MINIMUM" to the element name. If no
    minimum value is found, -TOOBIG is written here. As a fallback, if the
    FITS-style "DATAMIN" keyword is found and is appropriate, this is used.
<br><li><i>maximum :</i> 
    The minimum value will be written here. The name of the minimum
    value is constructed by appending "__MINIMUM" to the element name. If no
    minimum value is found, TOOBIG is written here. As a fallback, if the
    FITS-style "DATAMAX" keyword is found and is appropriate, this is used.
<br></ul><b>Returns:</b>     TRUE if either the minimum or maximum value were found,
    else FALSE
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_set_data_range></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_set_data_range</b><i>    (iarray array, double minimum, double maximum)
</i><br><p>    This routine will set the range of data in an Intelligent
    Array. The range information will be attached to the header.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The array.
<br><li><i>minimum :</i> 
    The minimum value. The name of the minimum value is constructed
    by appending "__MINIMUM" to the array value name (see
    <a href=iarray.html#iarray_value_name>iarray_value_name</a>).
    If appropriate, the FITS-style "DATAMIN" keyword is written instead.
<br><li><i>maximum :</i> 
    The maximum value. The name of the maximum value is constructed
    by appending "__MAXIMUM" to the array value name
    (see <a href=iarray.html#iarray_value_name>iarray_value_name</a>).
    If appropriate, the FITS-style "DATAMAX" keyword is written instead.
<br></ul><b>Returns:</b>     TRUE if the range information is different from what was
    already attached to the array, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_format_value></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>void
 <b>iarray_format_value</b><i>    (iarray array, char string[STRING_LENGTH],
			  double value, double scale, double offset)
</i><br><p>    Format a data value into a string.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array the value is associated with.
<br><li><i>string :</i> 
    The string to write to.
<br><li><i>value :</i> 
    The value to format.
<br><li><i>scale :</i> 
    The scale value to apply to the data. If this is TOOBIG the routine
    uses the scale and offset attached to the array. See
    <a href=iarray.html#iarray_set_data_scaling>iarray_set_data_scaling</a> for details.
<br><li><i>offset :</i> 
    The offset to apply after scaling the data.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_create_from_template></a> iarray
 <b>iarray_create_from_template</b><i>    (iarray template_arr,unsigned int elem_type,
				    flag copy_world_coords, flag copy_names,
				    flag copy_aux_info)
</i><br><p>    This routine will create an Intelligent Array of a specified type
    using an existing Intelligent Array as the template for the size,
    dimensionality and other attributes.
<p><b>Parameters:</b><ul><li><i>template_arr :</i> 
    The template Intelligent Array.
<br><li><i>elem_type :</i> 
    The element type for the new Intelligent Array.
<br><li><i>copy_world_coords :</i> 
    If TRUE, the world co-ordinates for each dimension in
    the template array are copied, otherwise the defaults are used.
<br><li><i>copy_names :</i> 
    If TRUE, the dimension names and the value name of the
    template array are copied, else the defaults are used.
<br><li><i>copy_aux_info :</i> 
    If TRUE, auxilary information (attachments) in the template
    array is copied to the new array.
<br></ul><b>Returns:</b>     An Intelligent Array on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_create_from_template2></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>iarray
 <b>iarray_create_from_template2</b><i>    (iarray template_arr,
				     unsigned int elem_type,
				     flag copy_world_coords, flag copy_names,
				     flag copy_aux_info, flag clear)
</i><br><p>    This routine will create an Intelligent Array of a specified type
    using an existing Intelligent Array as the template for the size,
    dimensionality and other attributes.
<p><b>Parameters:</b><ul><li><i>template_arr :</i> 
    The template Intelligent Array.
<br><li><i>elem_type :</i> 
    The element type for the new Intelligent Array.
<br><li><i>copy_world_coords :</i> 
    If TRUE, the world co-ordinates for each dimension in
    the template array are copied, otherwise the defaults are used.
<br><li><i>copy_names :</i> 
    If TRUE, the dimension names and the value name of the
    template array are copied, else the defaults are used.
<br><li><i>copy_aux_info :</i> 
    If TRUE, auxilary information (attachments) in the template
    array is copied to the new array.
<br><li><i>clear :</i> 
    If TRUE, the array is filled with zeros, otherwise the contents
    will be random.
<br></ul><b>Returns:</b>     An Intelligent Array on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_coordinate></a> double
 <b>iarray_get_coordinate</b><i>    (iarray array, unsigned int dim_index,
			      double coord_index)
</i><br><p>    Get a co-ordinate along a dimension.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>dim_index :</i> 
    The dimension index.
<br><li><i>coord_index :</i> 
    The co-ordinate index.
<br></ul><b>Returns:</b>     The co-ordinate on success, else TOOBIG.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_set_dim_name></a> void
 <b>iarray_set_dim_name</b><i>    (iarray array, unsigned int index, CONST char *name,
			  flag new_alloc)
</i><br><p>    Change the name of a dimension of an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>index :</i> 
    The index of the dimension.
<br><li><i>name :</i> 
    The new dimension name.
<br><li><i>new_alloc :</i> 
    If TRUE, the routine will allocate a new copy of the dimension
    name, else it will copy the pointer (in which case the name must never be
    externally deallocated or changed).
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_append_history_string></a> flag
 <b>iarray_append_history_string</b><i>    (iarray array, CONST char *string,
				   flag new_alloc)
</i><br><p>    Add a history string to an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>string :</i> 
    The history string to add.
<br><li><i>new_alloc :</i> 
    If TRUE, the routine will allocate a new copy of the history
    string, else it will copy the pointer (in which case the string must never
    be externally deallocated or changed).
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_copy_named_element></a> flag
 <b>iarray_copy_named_element</b><i>    (iarray out, iarray in, CONST char *name,
				flag fail_if_not_found,
				flag fail_on_duplicate, flag replace)
</i><br><p>    Copy a named element from one Intelligent Array to another.
<p><b>Parameters:</b><ul><li><i>out :</i> 
    The output Intelligent Array.
<br><li><i>in :</i> 
    The input Intelligent Array.
<br><li><i>name :</i> 
    The name of the element to copy.
<br><li><i>fail_if_not_found :</i> 
    If TRUE, the routine will fail if the element does not
    exist in the input packet.
<br><li><i>fail_on_duplicate :</i> 
    If TRUE, the routine will fail if the element already
    exists in the output packet.
<br><li><i>replace :</i> 
    If TRUE and the element already exists in the output packet, it
    is replaced.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_fits_axis></a> unsigned int
 <b>iarray_get_fits_axis</b><i>    (iarray array, unsigned int index)
</i><br><p>    Get the FITS axis number of a dimension.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>index :</i> 
    The index of the dimension.
<br></ul><b>Returns:</b>     The FITS axis number on success, else 0.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_create_and_setup></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_create_and_setup</b><i>    (iarray *array, multi_array *multi_desc,
			      flag inform, unsigned int num_dim,
			      unsigned int required_type,
			      double *min, double *max,
			      flag discard_zero_range, KwcsAstro *ap)
</i><br><p>    This routine will attempt to guess the filetype of a file and
    in the file, converting to an Intelligent Array if possible. The routine
    then performs some simple checks and some other convenience functions.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array is written here. An existing array pointed to
    by this is deallocated.
<br><li><i>multi_desc :</i> 
    The multi_array descriptor. If this is NULL, any existing data
    is deallocated and no further action is taken.
<br><li><i>inform :</i> 
    If TRUE, the routine displays some informative messages.
<br><li><i>num_dim :</i> 
    The number of dimensions required. If this is 0, any number of
    dimensions is allowed.
<br><li><i>required_type :</i> 
    The required data type. If this is NONE, then no type is
    required.
<br><li><i>min :</i> 
    The minimum data value in the array is written here. If this is NULL
    nothing is written here.
<br><li><i>max :</i> 
    The maximum data value in the array is written here. If this is NULL
    nothing is written here.
<br><li><i>discard_zero_range :</i> 
    If TRUE, and the range of the data is zero, the
    routine fails.
<br><li><i>ap :</i> 
    The KwcsAstro object is written here. This may be NULL.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_associated_wcs_astro></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>KwcsAstro
 <b>iarray_get_associated_wcs_astro</b><i>    (iarray array)
</i><br><p>    Get the KwcsAstro object associated with an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br></ul><b>Returns:</b>     The KwcsAstro object if associated, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_set_value_name></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>void
 <b>iarray_set_value_name</b><i>    (iarray array, CONST char *name, flag new_alloc)
</i><br><p>    Change the data name of an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>name :</i> 
    The new data value name. If the is NULL, the programme will abort.
<br><li><i>new_alloc :</i> 
    If TRUE, the routine will allocate a new copy of the value
    name, else it will copy the pointer (in which case the name must never be
    externally deallocated or changed).
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_find_centroid></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_find_centroid</b><i>    (iarray array, double *background, flag *inverted,
			   double *xpos, uaddr xradius,
			   double *ypos, uaddr yradius)
</i><br><p>    This routine will search for the centroid of an object inside a
    specified ellipse.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>inverted :</i> 
    If TRUE the algorithms should search for a minimum, rather than
    a maximum.
<br><li><i>background :</i> 
    The background value is written here. This may be NULL.
<br><li><i>inverted :</i> 
    The value TRUE will be written here if the image values are
    inverted (i.e. the object of interested is in a local minimum rather than a
    maximum).
<br><li><i>xpos :</i> 
    The horizontal data pixel position. The original value must be a
    reasonable approximation. This is modified to the centroid position.
<br><li><i>xradius :</i> 
    The horizontal radius of the ellipse.
<br><li><i>ypos :</i> 
    The vertical data pixel position. The original value must be a
    reasonable approximation. This is modified to the centroid position.
<br><li><i>yradius :</i> 
    The vertical radius of the ellipse.
<br></ul><b>Returns:</b>     TRUE on succes, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     (0.0, 0.0) corresponds to the centre of the first pixel.
</ul><p><hr> <a name=iarray_copy_attached></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_copy_attached</b><i>    (iarray output, iarray input, flag fail_on_duplicate,
			   flag replace)
</i><br><p>    Copy attached data from one Intelligent Array to another.
<p><b>Parameters:</b><ul><li><i>output :</i> 
    The output Intelligent Array.
<br><li><i>input :</i> 
    The input Intelligent Array.
<br><li><i>fail_on_duplicate :</i> 
    If TRUE, the routine will fail if the element already
    exists in the output packet.
<br><li><i>replace :</i> 
    If TRUE and the element already exists in the output packet, it
    is replaced.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_compare_grids_2D></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_compare_grids_2D</b><i>    (iarray array1,
			      unsigned int hdim1, unsigned int vdim1,
			      iarray array2,
			      unsigned int hdim2, unsigned int vdim2,
			      flag *same)
</i><br><p>    Compare if two image slices have the same world co-ordinate grid.
<p><b>Parameters:</b><ul><li><i>array1 :</i> 
    The array containing the first image slice.
<br><li><i>hdim1 :</i> 
    The horizontal dimension of the first image slice.
<br><li><i>vdim1 :</i> 
    The vertical dimension of the first image slice.
<br><li><i>array2 :</i> 
    The array containing the second image slice.
<br><li><i>hdim2 :</i> 
    The horizontal dimension of the second image slice.
<br><li><i>vdim2 :</i> 
    The vertical dimension of the second image slice.
<br><li><i>same :</i> 
    TRUE is written here if the grids are the same, else FALSE is
    written here.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE, indicating that comparison failed.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_beam_correction></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>double
 <b>iarray_get_beam_correction</b><i>    (iarray array, unsigned int dim1,
				   unsigned int dim2)
</i><br><p>    Get the beam correction for an area in an array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The array.
<br><li><i>dim1 :</i> 
    One of the dimensions.
<br><li><i>dim2 :</i> 
    The other dimension.
<br></ul><b>Returns:</b>     The beam correction, if available, else TOOBIG.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_register_data_change></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>void
 <b>iarray_register_data_change</b><i>    (iarray array, void *call_data)
</i><br><p>    Notify data for Intelligent Array has changed.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The array.
<br><li><i>call_data :</i> 
    The call data.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_values></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>void
 <b>iarray_get_values</b><i>    (iarray array, CONST uaddr *coords, double *values,
			flag *complex, unsigned int num_values)
</i><br><p>    This routine will convert many values along the least significant
    axis of an Intelligent Array to an array of double precision complex
    values.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The array.
<br><li><i>coords :</i> 
    The co-ordinate position to start converting from. The length of
    this array must equal the number of dimensions in the Intelligent Array.
<br><li><i>values :</i> 
    The data values will be written here. Must be a  double  boundary.
<br><li><i>complex :</i> 
    If the data are a complex type, then the value of TRUE is
    written here, else the value FALSE is written here. If this is NULL,
    nothing is written here.
<br><li><i>num_values :</i> 
    The number of data values to convert.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Safe.
<br><p><hr> <a name=iarray_moment_compute></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_moment_compute</b><i>    (iarray mom0, iarray mom1, iarray cube,
			    float lower_clip, float sum_clip,
			    unsigned int moment1_algorithm,
			    unsigned int start_z, unsigned int stop_z,
			    float *mom0_min, float *mom0_max)
</i><br><p>    Compute the 0th and 1st moments along the Z axis of a cube.
<p><b>Parameters:</b><ul><li><i>mom0 :</i> 
    The 0th moment array.
<br><li><i>mom1 :</i> 
    The 1st moment array.
<br><li><i>cube :</i> 
    The cube.
<br><li><i>lower_clip :</i> 
    Values in the cube lower than this value are not used in the
    computation of the moments.
<br><li><i>sum_clip :</i> 
    Values in the 0th moment map lower than this value are not used
    in the computation of the 1st moment.
<br><li><i>moment1_algorithm :</i> 
    The 1st moment algorithm.
<br><li><i>start_z :</i> 
    The start channel.
<br><li><i>stop_z :</i> 
    The stop channel.
<br><li><i>mom0_min :</i> 
    The minimum value in the 0th moment image is written here.
<br><li><i>mom0_max :</i> 
    The maximum value in the 0th moment image is written here.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_moment_create></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_moment_create</b><i>    (iarray *mom0, iarray *mom1, iarray cube)
</i><br><p>    Create 2-D arrays to contain computed moment maps.
<p><b>Parameters:</b><ul><li><i>mom0 :</i> 
    The Intelligent Array for the 0th moment is written here.
<br><li><i>mom1 :</i> 
    The Intelligent Array for the 1st moment is written here.
<br><li><i>cube :</i> 
    The cube from which the moment maps are created.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_write_mono_ps></a> flag
 <b>iarray_write_mono_ps</b><i>    (iarray image, PostScriptPage pspage,
			   double xstart, double ystart,
			   double xend, double yend, flag iscale)
</i><br><p>    This routine will convert a 2-dimensional Intelligent Array to
    monochrome PostScript. The routine does NOT write PostScript headers or
    tails.
<p><b>Parameters:</b><ul><li><i>image :</i> 
    The Intelligent Array.
<br><li><i>pspage :</i> 
    The PostScriptPage object.
<br><li><i>xstart :</i> 
    The x starting point (scaled from 0.0 to 1.0).
<br><li><i>ystart :</i> 
    The y starting point (scaled from 0.0 to 1.0).
<br><li><i>xend :</i> 
    The x ending point (scaled from 0.0 to 1.0).
<br><li><i>yend :</i> 
    The y ending point (scaled from 0.0 to 1.0).
<br><li><i>iscale :</i> 
    If FALSE and the input Intelligent Array is of type K_UBYTE the
    images values will be unscaled prior to PostScript conversion (0 = black,
    255 = white), otherwise (min = black, max = white).
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_write_pseudocolour_ps></a> flag
 <b>iarray_write_pseudocolour_ps</b><i>    (iarray image, PostScriptPage pspage,
				   double xstart, double ystart,
				   double xend, double yend,
				   unsigned short *cmap,unsigned int cmap_size)
</i><br><p>    This routine will convert a 2-dimensional Intelligent Array to
    colour PostScript. The routine does NOT write PostScript headers or tails.
<p><b>Parameters:</b><ul><li><i>image :</i> 
    The Intelligent Array.
<br><li><i>pspage :</i> 
    The PostScriptPage object.
<br><li><i>xstart :</i> 
    The x starting point (scaled from 0.0 to 1.0).
<br><li><i>ystart :</i> 
    The y starting point (scaled from 0.0 to 1.0).
<br><li><i>xend :</i> 
    The x ending point (scaled from 0.0 to 1.0).
<br><li><i>yend :</i> 
    The y ending point (scaled from 0.0 to 1.0).
<br><li><i>cmap :</i> 
    The colourmap. This must be the same format as returned by
    <a href=ds.html#ds_cmap_find_colourmap>ds_cmap_find_colourmap</a>.
<br><li><i>cmap_size :</i> 
    The size of the colourmap. The maximum size is 256.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_write_rgb_ps></a> flag
 <b>iarray_write_rgb_ps</b><i>    (iarray image_red, iarray image_green,
			  iarray image_blue, PostScriptPage pspage,
			  double xstart, double ystart,
			  double xend, double yend)
</i><br><p>    This routine will convert three 2-dimensional Intelligent Arrays
    to colour PostScript. The routine does NOT write PostScript headers or
    tails.
<p><b>Parameters:</b><ul><li><i>image_red :</i> 
    The Intelligent Array containing the red image component.
<br><li><i>image_green :</i> 
    The Intelligent Array containing the green image component.
<br><li><i>image_blue :</i> 
    The Intelligent Array containing the blue image component.
<br><li><i>pspage :</i> 
    The PostScriptPage object.
<br><li><i>xstart :</i> 
    The x starting point (scaled from 0.0 to 1.0).
<br><li><i>ystart :</i> 
    The y starting point (scaled from 0.0 to 1.0).
<br><li><i>xend :</i> 
    The x ending point (scaled from 0.0 to 1.0).
<br><li><i>yend :</i> 
    The y ending point (scaled from 0.0 to 1.0).
<br><li><i>cmap :</i> 
    The colourmap. This must be the same format as returned by
    <a href=ds.html#ds_cmap_find_colourmap>ds_cmap_find_colourmap</a>.
<br><li><i>cmap_size :</i> 
    The size of the colourmap. The maximum size is 256.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     Each of these Intelligent Arrays must be of type K_UBYTE.
</ul><p><hr> <a name=iarray_regrid_2D></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_regrid_2D</b><i>    (iarray out_arr, KwcsAstro out_ap,
		       iarray in_arr, KwcsAstro in_ap,
		       unsigned int sample_option, float *min, float *max,
		       flag verbose)
</i><br><p>    Regrid an array by iterating over the output array.
<p><b>Parameters:</b><ul><li><i>out_arr :</i> 
    The output array. The new grid must already be defined.
<br><li><i>out_ap :</i> 
    The output KwcsAstro object.
<br><li><i>in_arr :</i> 
    The input array.
<br><li><i>in_ap :</i> 
    The input KwcsAstro object.
<br><li><i>sample_option :</i> 
    The sample option to use.
<br><li><i>min :</i> 
    The minimum value is written here. This is updated. This may be NULL.
<br><li><i>max :</i> 
    The maximum value is written here. This is updated. This may be NULL.
<br><li><i>verbose :</i> 
    If TRUE, diagnostic messages are displayed.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The pair of axes in each array must correspond, otherwise no
    regridding is performed. Axes may be swapped and have different projections
    but different reference frames (for velocity axes) or equinoxes (for
    equatorial co-ordinates) are not permitted.
</ul><p><hr> <a name=iarray_regrid_3D></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_regrid_3D</b><i>    (iarray out_arr, KwcsAstro out_ap,
		       iarray in_arr, KwcsAstro in_ap,
		       unsigned int sample_option, float *min, float *max,
		       flag verbose)
</i><br><p>    Regrid an array by iterating over the output array.
<p><b>Parameters:</b><ul><li><i>out_arr :</i> 
    The output array. The new grid must already be defined.
<br><li><i>out_ap :</i> 
    The output KwcsAstro object.
<br><li><i>in_arr :</i> 
    The input array.
<br><li><i>in_ap :</i> 
    The input KwcsAstro object.
<br><li><i>sample_option :</i> 
    The sample option to use.
<br><li><i>min :</i> 
    The minimum value is written here. This is updated. This may be NULL.
<br><li><i>max :</i> 
    The maximum value is written here. This is updated. This may be NULL.
<br><li><i>verbose :</i> 
    If TRUE, diagnostic messages are displayed.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_scroll></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>void
 <b>iarray_scroll</b><i>    (iarray array, unsigned long num_to_scroll,
		    unsigned int scroll_mode)
</i><br><p>    This routine will scroll "down" an array by a specified number of
    co-ordinates along the major dimension (dimension 0).
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array to scroll.
<br><li><i>num_to_scroll :</i> 
    The number of co-ordinates to scroll by.
<br><li><i>scroll_mode :</i> 
    The scroll mode.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_rect_to_polar></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>void
 <b>iarray_rect_to_polar</b><i>    (iarray out, iarray in,
			   double centre_x, double centre_y,
			   double radius_major, double radius_minor,
			   double rotation)
</i><br><p>    This routine will transform an input image with a rectangular
    co-ordinate system to an output image with a polar co-ordinate system.
    Lines of constant radius in the output image correspond to the points
    around an ellipse in the input image. The X axis in the output image will
    correspond to different radii bins, while the Y axis will correspond to
    different angle bins. The last X axis index will correspond to the outer
    ellipse.
<p><b>Parameters:</b><ul><li><i>out :</i> 
    The output 2D Intelligent Array of type K_FLOAT. The polar image is
    written here. This must be externally allocated.
<br><li><i>in :</i> 
    The input 2D Intelligent Array of type K_FLOAT. This must contain the
    input rectangular image.
<br><li><i>centre_x :</i> 
    The X centre of the new polar co-ordinate system in the input.
<br><li><i>centre_y :</i> 
    The Y centre of the new polar co-ordinate system in the input.
<br><li><i>radius_major :</i> 
    The radius of the major axis of the outer ellipse.
<br><li><i>radius_minor :</i> 
    The radius of the minor axis of the outer ellipse.
<br><li><i>rotation :</i> 
    The rotation of the ellipse, in degrees. An angle of 0 would
    mean the major axis is parallel to the input image X axis.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_transform_3D></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_transform_3D</b><i>    (iarray out_arr, KwcsAstro out_ap,
			  iarray in_arr, KwcsAstro in_ap,
			  void (*func) (void *info, unsigned long length,
					double *x, double *y, double *z),
			  void *info)
</i><br><p>    Transform an array by iterating over the input array.
<p><b>Parameters:</b><ul><li><i>out_arr :</i> 
    The output array. The new grid must already be defined.
<br><li><i>out_ap :</i> 
    The output KwcsAstro object.
<br><li><i>in_arr :</i> 
    The input array.
<br><li><i>in_ap :</i> 
    The input KwcsAstro object.
<br><li><i>func :</i> 
    The function used to convert from input world co-ordinates to output
    world co-ordinates.
<br><li><i>info :</i> 
    An arbitrary information pointer passed to <em>func</em>.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     Aliasing artefacts may appear if the output grid resolution is too
    high. This is an inherent problem with forward transform algorithms. If
    an inverse co-ordinate transform function is available, then use
    <a href=iarray.html#iarray_untransform_3D>iarray_untransform_3D</a> instead, which avoids these artefacts.
</ul><p><hr> <a name=iarray_untransform_3D></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>iarray_untransform_3D</b><i>    (iarray out_arr, KwcsAstro out_ap,
			    iarray in_arr, KwcsAstro in_ap,
			    void (*func) (void *info, unsigned long length,
					  double *x, double *y, double *z),
			    void *info)
</i><br><p>    Transform an array by iterating over the output array.
<p><b>Parameters:</b><ul><li><i>out_arr :</i> 
    The output array. The new grid must already be defined.
<br><li><i>out_ap :</i> 
    The output KwcsAstro object.
<br><li><i>in_arr :</i> 
    The input array.
<br><li><i>in_ap :</i> 
    The input KwcsAstro object.
<br><li><i>func :</i> 
    The function used to convert from output world co-ordinates to input
    world co-ordinates.
<br><li><i>info :</i> 
    An arbitrary information pointer passed to <em>func</em>.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_create_1D></a> iarray
 <b>iarray_create_1D</b><i>    (unsigned long xlen, unsigned int type)
</i><br><p>    This routine will create a 1-dimensional "Intelligent Array",
    using the Karma general data structure format as the underlying data format
<p><b>Parameters:</b><ul><li><i>xlen :</i> 
    The length of the dimension. The name of the dimension will be the
    default: "Axis 0".
<br><li><i>type :</i> 
    The type of the data. See <a href=ds.html#ds_KARMA_DATA_TYPES>ds_KARMA_DATA_TYPES</a> for a list of
    defined data types.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The name of the element will be the default name: "Intensity".
</ul><p><hr> <a name=iarray_create_2D></a> iarray
 <b>iarray_create_2D</b><i>    (unsigned long ylen, unsigned long xlen,
			 unsigned int type)
</i><br><p>    This routine will create a 2-dimensional "Intelligent Array",
    using the Karma general data structure format as the underlying data format
<p><b>Parameters:</b><ul><li><i>ylen :</i> 
    The length of the most significant dimension (ie. the dimension with
    the greatest stride in memory.
<br><li><i>xlen :</i> 
    The length of the least significant dimension.
<br><li><i>type :</i> 
    The type of the data. See <a href=ds.html#ds_KARMA_DATA_TYPES>ds_KARMA_DATA_TYPES</a> for a list of
    defined data types.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The names of the dimensions will be the defaults: "Axis 0" and
    "Axis 1", respectively.
<li>     The name of the element will be the default name: "Intensity".
</ul><p><hr> <a name=iarray_create_3D></a> iarray
 <b>iarray_create_3D</b><i>    (unsigned long zlen, unsigned long ylen,
			 unsigned long xlen, unsigned int type)
</i><br><p>    This routine will create a 3-dimensional "Intelligent Array",
    using the Karma general data structure format as the underlying data format
<p><b>Parameters:</b><ul><li><i>zlen :</i> 
    The length of the most significant dimension (ie. the dimension with
    the greatest stride in memory).
<br><li><i>ylen :</i> 
    The length of the middle dimension.
<br><li><i>xlen :</i> 
    The length of the least significant dimension.
<br><li><i>type :</i> 
    The type of the data. See <a href=ds.html#ds_KARMA_DATA_TYPES>ds_KARMA_DATA_TYPES</a> for a list of
    defined data types.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The names of the dimensions will be the defaults: "Axis 0",
    "Axis 1" and "Axis 2", respectively.
<li>     The name of the element will be the default name: "Intensity".
</ul><p><hr> <a name=iarray_create_4D></a> iarray
 <b>iarray_create_4D</b><i>    (unsigned long zlen, unsigned long ylen,
			 unsigned long xlen, unsigned int wlen,
			 unsigned int type)
</i><br><p>    This routine will create a 4-dimensional "Intelligent Array",
    using the Karma general data structure format as the underlying data format
<p><b>Parameters:</b><ul><li><i>zlen :</i> 
    The length of the most significant dimension (ie. the dimension with
    the greatest stride in memory).
<br><li><i>ylen :</i> 
    The length of the second most significant dimension.
<br><li><i>xlen :</i> 
    The length of the second least significant dimension.
<br><li><i>wlen :</i> 
    The length of the least significant dimension.
<br><li><i>type :</i> 
    The type of the data. See <a href=ds.html#ds_KARMA_DATA_TYPES>ds_KARMA_DATA_TYPES</a> for a list of
    defined data types.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The names of the dimensions will be the defaults: "Axis 0",
    "Axis 1", "Axis 2" and "Axis 3", respectively.
<li>     The name of the element will be the default name: "Intensity".
</ul><p><hr> <a name=iarray_create_shm></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>iarray
 <b>iarray_create_shm</b><i>    (unsigned int type, unsigned int num_dim,
			  CONST char **dim_names, CONST uaddr *dim_lengths,
			  CONST char *elem_name, flag force)
</i><br><p>    Create an n-dimensional Intelligent Array in shared memory.
<p><b>Parameters:</b><ul><li><i>type :</i> 
    The desired type of the data elements. See <a href=ds.html#ds_KARMA_DATA_TYPES>ds_KARMA_DATA_TYPES</a>
    for a list of defined data types.
<br><li><i>num_dim :</i> 
    The number of dimensions the array must have.
<br><li><i>dim_names :</i> 
    The names of the dimensions. If this is NULL, the default names
    "Axis 0", "Axis 1", etc. are used.
<br><li><i>dim_lengths :</i> 
    The lengths of the dimensions. The first entry in this array
    and the <em>dim_names</em> array refers to the most significant dimension
    (i.e. the dimension with the greatest stride in memory).
<br><li><i>elem_name :</i> 
    The name of the element. If this is NULL, the default name
    "Data Value" is choosen.
<br><li><i>force :</i> 
    If TRUE the routine will fail if shared memory could not be
    allocated or is not available, otherwise the routine falls back to
    ordinary memory if shared memory could not be allocated.
<br></ul><b>Returns:</b>     A dynamically allocated intelligent array on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_put_double></a> flag
 <b>iarray_put_double</b><i>    (iarray array, CONST char *name, double value)
</i><br><p>    This routine will put a unique named float value into the
    underlying Karma general data structure of an "Intelligent Array".
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>name :</i> 
    The name of the element.
<br><li><i>value :</i> 
    The value of the data.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_put_float></a> flag
 <b>iarray_put_float</b><i>    (iarray array, CONST char *name, float value)
</i><br><p>    This routine will put a unique named float value into the
    underlying Karma general data structure of an "Intelligent Array".
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>name :</i> 
    The name of the element.
<br><li><i>value :</i> 
    The value of the data.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_put_int></a> flag
 <b>iarray_put_int</b><i>    (iarray array, CONST char *name, int value)
</i><br><p>    This routine will put a unique named integer value into the
    underlying Karma general data structure of an "Intelligent Array".
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>name :</i> 
    The name of the element.
<br><li><i>value :</i> 
    The value of the data.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_double></a> flag
 <b>iarray_get_double</b><i>    (iarray array, CONST char *name, double *value,
			flag abort_on_error)
</i><br><p>    This routine will get a unique named double precision floating
    point value from the underlying Karma general data structure of an
    "Intelligent Array".
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>name :</i> 
    The name of the element.
<br><li><i>value :</i> 
    The value is written here.
<br><li><i>abort_on_error :</i> 
    If TRUE, the routine aborts on error.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_float></a> float
 <b>iarray_get_float</b><i>    (iarray array, CONST char *name)
</i><br><p>    This routine will get a unique named float value from the
    underlying Karma general data structure of an "Intelligent Array".
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>name :</i> 
    The name of the element.
<br></ul><b>Returns:</b>     The value on success, else the process is aborted on error.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_get_int></a> int
 <b>iarray_get_int</b><i>    (iarray array, CONST char *name)
</i><br><p>    This routine will get a unique named integer value from the
    underlying Karma general data structure of an "Intelligent Array".
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>name :</i> 
    The name of the element.
<br></ul><b>Returns:</b>     The value on success, else the process is aborted on error.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_fill_double></a> flag
 <b>iarray_fill_double</b><i>    (iarray array, double value)
</i><br><p>    Fill an Intelligent Array with a double precision float value.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>value :</i> 
    The fill value.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     If filling a complex array, both the real and imaginary components
    are filled with the fill value.
</ul><p><hr> <a name=iarray_fill_float></a> flag
 <b>iarray_fill_float</b><i>    (iarray array, float value)
</i><br><p>    Fill an Intelligent Array with a single float value.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>value :</i> 
    The fill value.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     If filling a complex array, both the real and imaginary components
    are filled with the fill value.
</ul><p><hr> <a name=iarray_fill_int></a> flag
 <b>iarray_fill_int</b><i>    (iarray array, int value)
</i><br><p>    Fill an Intelligent Array with a single integer value.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>value :</i> 
    The fill value.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     If filling a complex array, both the real and imaginary components
    are filled with the fill value.
</ul><p><hr> <a name=iarray_min_max_float></a> flag
 <b>iarray_min_max_float</b><i>    (iarray array, float *min, float *max)
</i><br><p>    Determine the minimum and maximum value of an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>min :</i> 
    The routine will write the minimum value here.
<br><li><i>max :</i> 
    The routine will write the maximum value here.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe.
<br><b>Note:</b><ul> <li>     If the array is a complex array, then the routine computes the
    minimum and maximum magnitudes.
</ul><p><hr> <a name=iarray_min_max_int></a> flag
 <b>iarray_min_max_int</b><i>    (iarray array, int *min, int *max)
</i><br><p>    Determine the minimum and maximum value of an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>min :</i> 
    The routine will write the minimum value here.
<br><li><i>max :</i> 
    The routine will write the maximum value here.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe.
<br><b>Note:</b><ul> <li>     If the array is a complex array, then the routine computes the
    minimum and maximum magnitudes.
</ul><p><hr> <a name=iarray_scale_and_offset_float></a> flag
 <b>iarray_scale_and_offset_float</b><i>    (iarray out, iarray inp, float scale, 
				    float offset)
</i><br><p>    This routine will perform a scale and offset on every element in
    an "Intelligent Array" (output = input * scale + offset).
<p><b>Parameters:</b><ul><li><i>out :</i> 
    The output Intelligent Array.
<br><li><i>inp :</i> 
    The input Intelligent Array.
<br><li><i>scale :</i> 
    The complex scale value.
<br><li><i>offset :</i> 
    The complex offset value.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The input and output arrays MUST be the same size (though not
    necessarily the same type).
<li>     When converting from a complex to a real array, the magnitude is
    scaled and offset.
<li>     When converting from a real to a complex array, the imaginary
    component of the output array is set to 0.
</ul><p><hr> <a name=iarray_scale_and_offset_int></a> flag
 <b>iarray_scale_and_offset_int</b><i>    (iarray out, iarray inp, int scale,int offset)
</i><br><p>    This routine will perform a scale and offset on every element in
    an "Intelligent Array" (output = input * scale + offset).
<p><b>Parameters:</b><ul><li><i>out :</i> 
    The output Intelligent Array.
<br><li><i>inp :</i> 
    The input Intelligent Array.
<br><li><i>scale :</i> 
    The complex scale value.
<br><li><i>offset :</i> 
    The complex offset value.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The input and output arrays MUST be the same size (though not
    necessarily the same type).
<li>     When converting from a complex to a real array, the magnitude is
    scaled and offset.
<li>     When converting from a real to a complex array, the imaginary
    component of the output array is set to 0.
</ul><p><hr> <a name=iarray_num_dim></a> unsigned int
 <b>iarray_num_dim</b><i>    (iarray array)
</i><br><p>    Get number of dimensions in an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br></ul><b>Returns:</b>     The number of dimensions.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_type></a> unsigned int
 <b>iarray_type</b><i>    (iarray array)
</i><br><p>    Get type of data in an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br></ul><b>Returns:</b>     The type of the data in the array.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_value_name></a> CONST char *
 <b>iarray_value_name</b><i>    (iarray array)
</i><br><p>    Get name of data in an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br></ul><b>Returns:</b>     The name of the data in the array.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_register_destroy_func></a> KCallbackFunc
 <b>iarray_register_destroy_func</b><i>    (iarray array,
					    void (*destroy_func) (iarray array,
								  void *info),
					    void *info)
</i><br><p>    Register destroy function for an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>destroy_func :</i> 
    The routine that is called when the array is destroyed. The
    prototype function is <a href=iarray.html#iarray_PROTO_destroy_func>iarray_PROTO_destroy_func</a>.
<br><li><i>info :</i> 
    The arbitrary information pointer.
<br></ul><b>Returns:</b>     A KCallbackFunc object. On failure, the process aborts.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_multi_array></a> multi_array *
 <b>iarray_multi_array</b><i>    (array)
</i><br><p>    Get the multi_array for an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br></ul><b>Returns:</b>     The multi_array.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_multi_index></a> unsigned int
 <b>iarray_multi_index</b><i>    (array)
</i><br><p>    Get the index of the Intelligent Array within the multi_array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br></ul><b>Returns:</b>     The index.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_array_desc></a> multi_array *
 <b>iarray_array_desc</b><i>    (array)
</i><br><p>    Get the array_desc for an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br></ul><b>Returns:</b>     The array_desc.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_arrayp></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>array_pointer *
 <b>iarray_arrayp</b><i>    (array)
</i><br><p>    Get the array_pointer for an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br></ul><b>Returns:</b>     A pointer to the array_pointer. This pointer is invalidated by
    any operation that causes the top level packet data to be reallocated.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=iarray_register_data_change_func></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>KCallbackFunc
 <b>iarray_register_data_change_func</b><i>    (iarray array,
						void (*func) (void *info),
						void *info)
</i><br><p>    Register data change function for an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>func :</i> 
    The routine that is called when the the underlying array data are
    changed.
<br><li><i>info :</i> 
    The arbitrary information pointer.
<br></ul><b>Returns:</b>     A KCallbackFunc object. On failure, the process aborts.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr><center><h2>Prototype Functions</h2></center><hr> <a name=iarray_PROTO_destroy_func></a> void
 <b>iarray_PROTO_destroy_func</b><i>    (iarray array, void *info)
</i><br><p>    Register destruction of an Intelligent Array.
<p><b>Parameters:</b><ul><li><i>array :</i> 
    The Intelligent Array.
<br><li><i>info :</i> 
    A pointer to the arbitrary information.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p>
<hr><a href="../index.html">Back to Karma Home Page</a>
<hr><center><address>Contact: <a href="http://www.atnf.csiro.au/~rgooch/">Richard Gooch</a><br>Web Development: <a href="http://www.ariel.com.au/">Ariel Internet Services</a></address></center></body></html>
