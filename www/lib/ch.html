<html><head><title>Package: ch</title></head> 
<body>
<center><h1>The "ch" Package</h1></center>    These routines are meant to provide an alternative to the standard C
    library streams (FILE *).
    The channel package provides far more powerful channels (streams),
    especially when transferring data over connections.
<p><b>Library:</b> karma
<br><b>Link With:</b> -lkarma
<br><p><a name=ch></a></table><h4>Functions</h4><table><tr><td><a href=ch.html#ch_open_file>ch_open_file</a></td><td>Open a file.
</td></tr>
<tr><td><a href=ch.html#ch_open_connection>ch_open_connection</a></td><td>Open a connection to a Karma server.
</td></tr>
<tr><td><a href=ch.html#ch_accept_on_dock>ch_accept_on_dock</a></td><td>Accept a connection.
</td></tr>
<tr><td><a href=ch.html#ch_alloc_port>ch_alloc_port</a></td><td>Allocate a port.
</td></tr>
<tr><td><a href=ch.html#ch_attach_to_asynchronous_descriptor>ch_attach_to_asynchronous_descriptor</a></td><td>Create a channel object from an asynchronous descriptor.
</td></tr>
<tr><td><a href=ch.html#ch_open_stdin>ch_open_stdin</a></td><td>Create starndard input channel.
</td></tr>
<tr><td><a href=ch.html#ch_open_stdout>ch_open_stdout</a></td><td>Create starndard output channel.
</td></tr>
<tr><td><a href=ch.html#ch_create_pipe>ch_create_pipe</a></td><td>Create a pipe.
</td></tr>
<tr><td><a href=ch.html#ch_create_socketpair>ch_create_socketpair</a></td><td>Create a pair of un-named connected sockets.
</td></tr>
<tr><td><a href=ch.html#ch_test_for_asynchronous>ch_test_for_asynchronous</a></td><td>Test if a channel object is an asynchronous channel.
</td></tr>
<tr><td><a href=ch.html#ch_test_for_connection>ch_test_for_connection</a></td><td>Test if a channel object is a connection channel.
</td></tr>
<tr><td><a href=ch.html#ch_test_for_local_connection>ch_test_for_local_connection</a></td><td>Test if a connection channel object is a local connection.
</td></tr>
<tr><td><a href=ch.html#ch_get_buffer_sizes>ch_get_buffer_sizes</a></td><td>Get the read and write buffer sizes for a channel.
</td></tr>
<tr><td><a href=ch.html#ch_set_buffer_sizes>ch_set_buffer_sizes</a></td><td>Set the read and write buffer sizes for a channel.
</td></tr>
<tr><td><a href=ch.html#ch_udp_alloc>ch_udp_alloc</a></td><td>Create a UDP socket and bind to a random port number.
</td></tr>
<tr><td><a href=ch.html#ch_set_nodelay>ch_set_nodelay</a></td><td>Set the no-delay flag for a channel if appropriate.
</td></tr>
<tr><td><a href=ch.html#ch_get_qos>ch_get_qos</a></td><td>Get the Quality of Service parameters for a connection.
</td></tr>
<tr><td><a href=ch.html#ch_register_close_func>ch_register_close_func</a></td><td>Register close callback.
</td></tr>
<tr><td><a href=ch.html#ch_close>ch_close</a></td><td>Close a channel.
</td></tr>
<tr><td><a href=ch.html#ch_flush>ch_flush</a></td><td>Flush the write buffer of a channel object.
</td></tr>
<tr><td><a href=ch.html#ch_read>ch_read</a></td><td>Read from a channel.
</td></tr>
<tr><td><a href=ch.html#ch_read2>ch_read2</a></td><td>Read from a channel.
</td></tr>
<tr><td><a href=ch.html#ch_write>ch_write</a></td><td>Write to a channel.
</td></tr>
<tr><td><a href=ch.html#ch_close_all_channels>ch_close_all_channels</a></td><td>Close all open channels.
</td></tr>
<tr><td><a href=ch.html#ch_seek>ch_seek</a></td><td>Move read/write pointer.
</td></tr>
<tr><td><a href=ch.html#ch_get_bytes_readable>ch_get_bytes_readable</a></td><td>Count unread bytes.
</td></tr>
<tr><td><a href=ch.html#ch_test_for_io>ch_test_for_io</a></td><td>Test if I/O possible on channel.
</td></tr>
<tr><td><a href=ch.html#ch_test_for_converters>ch_test_for_converters</a></td><td>Test if a channel object has converters.
</td></tr>
<tr><td><a href=ch.html#ch_tell>ch_tell</a></td><td>Get the read and write pointers for a channel.
</td></tr>
<tr><td><a href=ch.html#ch_register_converter>ch_register_converter</a></td><td>Register channel converter function.
</td></tr>
<tr><td><a href=ch.html#ch_unregister_converter>ch_unregister_converter</a></td><td>Unregister converter.
</td></tr>
<tr><td><a href=ch.html#ch_tap_io_events>ch_tap_io_events</a></td><td>Register I/O tap function.
</td></tr>
<tr><td><a href=ch.html#ch_test_valid>ch_test_valid</a></td><td>Test if a channel is valid.
</td></tr>
<tr><td><a href=ch.html#ch_skip>ch_skip</a></td><td>Skip bytes in a channel, seeking if possible.
</td></tr>
<tr><td><a href=ch.html#ch_get_descriptor>ch_get_descriptor</a></td><td>Get the file descriptor associated with a channel.
</td></tr>
<tr><td><a href=ch.html#ch_map_disc>ch_map_disc</a></td><td>Map a disc file.
</td></tr>
<tr><td><a href=ch.html#ch_map_fd>ch_map_fd</a></td><td>Map a disc file.
</td></tr>
<tr><td><a href=ch.html#ch_open_memory>ch_open_memory</a></td><td>Open a memory channel.
</td></tr>
<tr><td><a href=ch.html#ch_test_for_mmap>ch_test_for_mmap</a></td><td>Test if a channel object is a memory mapped disc channel.
</td></tr>
<tr><td><a href=ch.html#ch_get_mmap_addr>ch_get_mmap_addr</a></td><td>Get memory mapped address.
</td></tr>
<tr><td><a href=ch.html#ch_get_memory_addr>ch_get_memory_addr</a></td><td>Get memory address.
</td></tr>
<tr><td><a href=ch.html#ch_get_mmap_access_count>ch_get_mmap_access_count</a></td><td>Get memory mapped access count.
</td></tr>
<tr><td><a href=ch.html#ch_get_mem_size>ch_get_mem_size</a></td><td>Get memory buffer size.
</td></tr>
<tr><td><a href=ch.html#ch_open_and_fill_memory>ch_open_and_fill_memory</a></td><td>Create and fill memory channel.
</td></tr>
<tr><td><a href=ch.html#ch_gets>ch_gets</a></td><td>Read a line from a channel.
</td></tr>
<tr><td><a href=ch.html#ch_getl>ch_getl</a></td><td>Read a line from a channel.
</td></tr>
<tr><td><a href=ch.html#ch_puts>ch_puts</a></td><td>Write a character string to a channel.
</td></tr>
<tr><td><a href=ch.html#ch_drain>ch_drain</a></td><td>Drain bytes from a channel.
</td></tr>
<tr><td><a href=ch.html#ch_fill>ch_fill</a></td><td>Fill a channel with bytes.
</td></tr>
<tr><td><a href=ch.html#ch_printf>ch_printf</a></td><td>Write formatted output to a channel.
</td></tr>
<tr><td><a href=ch.html#ch_scanf>ch_scanf</a></td><td>Read formatted input from a channel.
</td></tr>
<tr><td><a href=ch.html#ch_drain_to_boundary>ch_drain_to_boundary</a></td><td>Drain bytes from a channel until a specified boundary.
</td></tr>
<tr><td><a href=ch.html#ch_skip_to_boundary>ch_skip_to_boundary</a></td><td>Skip bytes from a channel until a specified boundary.
</td></tr>
<tr><td><a href=ch.html#ch_fill_to_boundary>ch_fill_to_boundary</a></td><td>Write bytes to a channel until a specified boundary.
</td></tr>
<tr><td><a href=ch.html#ch_read_and_swap_blocks>ch_read_and_swap_blocks</a></td><td>Read blocks from a channel and swap bytes.
</td></tr>
<tr><td><a href=ch.html#ch_swap_and_write_blocks>ch_swap_and_write_blocks</a></td><td>Write blocks to a channel after swapping bytes.
</td></tr>
<tr><td><a href=ch.html#ch_copy>ch_copy</a></td><td>Copy bytes from one channel to another in an optimal way.
</td></tr>
<tr><td><a href=ch.html#ch_map_disc2>ch_map_disc2</a></td><td>Attempt to map a disc file, fallback to reading.
</td></tr>
<tr><td><a href=ch.html#ch_open_compressed_file>ch_open_compressed_file</a></td><td>Open a file, with possible decompression.
</td></tr>
<tr><td><a href=ch.html#ch_get_bytes_remaining_in_disc>ch_get_bytes_remaining_in_disc</a></td><td>Return the number of bytes remaining in a disc file.
</td></tr>
<tr><td><a href=ch.html#ch_create_sink>ch_create_sink</a></td><td>Create data sink.
</td></tr>
<tr><td><a href=ch.html#ch_create_zero>ch_create_zero</a></td><td>Create data source.
</td></tr>
</table><h4>Prototype Functions</h4><table><tr><td><a href=ch.html#ch_PROTO_converter_size_func>ch_PROTO_converter_size_func</a></td><td>Get number of bytes readable.
</td></tr>
<tr><td><a href=ch.html#ch_PROTO_converter_read_func>ch_PROTO_converter_read_func</a></td><td>Read bytes.
</td></tr>
<tr><td><a href=ch.html#ch_PROTO_converter_write_func>ch_PROTO_converter_write_func</a></td><td>Write bytes.
</td></tr>
<tr><td><a href=ch.html#ch_PROTO_converter_flush_func>ch_PROTO_converter_flush_func</a></td><td>Flush.
</td></tr>
<tr><td><a href=ch.html#ch_PROTO_converter_close_func>ch_PROTO_converter_close_func</a></td><td>Close.
</td></tr>
<tr><td><a href=ch.html#ch_PROTO_tap_func>ch_PROTO_tap_func</a></td><td>Tap I/O callback.
</td></tr>
<tr><td><a href=ch.html#ch_PROTO_close_func>ch_PROTO_close_func</a></td><td>Process a destroy event for an object.
</td></tr>
</table><h4>Tables</h4><table><tr><td><a href=ch.html#ch_FILE_MODES>ch_FILE_MODES</a></td><td>List of defined file modes
</td></tr>
<tr><td><a href=ch.html#ch_MAP_CONTROLS>ch_MAP_CONTROLS</a></td><td>List of mapping control values
</td></tr>
<tr><td><a href=ch.html#ch_ENVIRONMENT>ch_ENVIRONMENT</a></td><td>List of environment variables
</td></tr>
</table><p><hr><center><h2>Functions</h2></center><hr> <a name=ch_open_file></a> Channel
 <b>ch_open_file</b><i>    (CONST char *filename, CONST char *type)
</i><br><p>    This routine will open a file channel. The file may be a regular
    disc file, a named FIFO, a character special device, a Unix domain
    connection or a TCP/IP connection. The channel may be later tested
    to determine what the true channel type is by calling routines such as:
    <a href=ch.html#ch_test_for_asynchronous>ch_test_for_asynchronous</a> and <a href=ch.html#ch_test_for_io>ch_test_for_io</a>.
<p><b>Parameters:</b><ul><li><i>filename :</i> 
    The pathname of the file to open. This parameter has the same
    meaning as the first parameter to <em>open(2)</em>. Filenames of the form
    "//tcpIP/{hostname}:{port}" indicate a connection to a TCP/IP port on host
    <em>hostname</em> with raw port number <em>port</em> is requested.
<br><li><i>type :</i> 
    The mode of the file. See <a href=ch.html#ch_FILE_MODES>ch_FILE_MODES</a> for a list of allowable
    modes.
<br></ul><b>Returns:</b>     A channel object on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     For character special files and named FIFOs, these modes
    degenerate into read-write, read-only and write-only.
</ul><p><hr> <a name=ch_open_connection></a> Channel
 <b>ch_open_connection</b><i>    (unsigned long host_addr, unsigned int port_number)
</i><br><p>    This routine will open a full-duplex connection channel to a
    Karma server running on another host machine.
<p><b>Parameters:</b><ul><li><i>host_addr :</i> 
    The Internet address of the host machine. If this is 0 the
    connection is made to a server running on the same machine using the most
    efficient transport available.
<br><li><i>port_number :</i> 
    The Karma port number to connect to. This should not be
    confused with Internet port numbers.
<br></ul><b>Returns:</b>     A channel object on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The use of this routine is not recommended, see the <a href=conn.html#conn>conn</a>
    package for more powerful functionality.
</ul><p><hr> <a name=ch_accept_on_dock></a> Channel
 <b>ch_accept_on_dock</b><i>    (Channel dock, unsigned long *addr)
</i><br><p>    This routine will open a full-duplex connection channel to the
    first connection on a waiting dock.
<p><b>Parameters:</b><ul><li><i>dock :</i> 
    The dock.
<br><li><i>addr :</i> 
    The address of the host connecting to the dock will be written here.
<br></ul><b>Returns:</b>     A channel object on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_alloc_port></a> Channel *
 <b>ch_alloc_port</b><i>    (unsigned int *port_number, unsigned int retries,
			unsigned int *num_docks)
</i><br><p>    This routine will allocate a Karma port for the module so that it
    can operate as a server (able to receive network connections).
<p><b>Parameters:</b><ul><li><i>port_number :</i> 
    A pointer to the port number to allocate. The routine will
    write the actual port number allocated to this address. This must point to
    an address which lies on an <em>int</em> boundary.
<br><li><i>retries :</i> 
    The number of succsessive port numbers to attempt to allocate
    before giving up. If this is 0, then the routine will give up immediately
    if the specified port number is in use.
<br><li><i>num_docks :</i> 
    The routine will create a number of docks for one port. Each
    dock is an alternative access point for other modules to connect to this
    port. The number of docks allocated will be written here. This must point
    to an address which lies on an <em>int</em> boundary.
<br></ul><b>Returns:</b>     A pointer to an array of channel docks on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The close-on-exec flags of the docks are set such that the docks
    will close on a call to execve(2V).
<li>     The docks are placed into blocking mode.
</ul><p><hr> <a name=ch_attach_to_asynchronous_descriptor></a> Channel
 <b>ch_attach_to_asynchronous_descriptor</b><i>    (int fd)
</i><br><p>    Create a channel object from an asynchronous descriptor.
<p><b>Parameters:</b><ul><li><i>fd :</i> 
    The descriptor.
<br></ul><b>Returns:</b>     A channel object on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_open_stdin></a> void
 <b>ch_open_stdin</b><i>    ()
</i><br><p>    This routine will create a channel object for the standard input
    descriptor (typically 0 on Unix systems).
<p><b>Parameters:</b><ul>This function takes no parameters<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The standard input channel will be written to the external variable
    <em>ch_stdin</em>.
</ul><p><hr> <a name=ch_open_stdout></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>void
 <b>ch_open_stdout</b><i>    ()
</i><br><p>    This routine will create a channel object for the standard output
    descriptor (typically 1 on Unix systems).
<p><b>Parameters:</b><ul>This function takes no parameters<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The standard output channel will be written to the external variable
    <em>ch_stdout</em>.
</ul><p><hr> <a name=ch_create_pipe></a> flag
 <b>ch_create_pipe</b><i>    (Channel *read_ch, Channel *write_ch)
</i><br><p>    This routine will create an un-named pipe (see <em>pipe(2)</em> for
    details on un-named pipes).
<p><b>Parameters:</b><ul><li><i>read_ch :</i> 
    The channel corresponding to the read end of the pipe will be
    written here.
<br><li><i>write_ch :</i> 
    The channel corresponding to the write end of the pipe will be
    written here.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE and sets <em>errno</em> with the error
    code.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_create_socketpair></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>ch_create_socketpair</b><i>    (Channel *ch1, Channel *ch2)
</i><br><p>    Create a pair of un-named connected sockets.
<p><b>Parameters:</b><ul><li><i>ch1 :</i> 
    The channel corresponding to one end of the pair is written here.
<br><li><i>ch2 :</i> 
    The channel corresponding to the other end of the pair is written
    here.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE and sets <em>errno</em> with the error
    code.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_test_for_asynchronous></a> flag
 <b>ch_test_for_asynchronous</b><i>    (Channel channel)
</i><br><p>    This routine will test if a channel object is an asynchronous
    channel, i.e. a character special file, named FIFO, connection, a dock
    channel or one created by a call to
    <em>ch_attach_to_asynchronous_descriptor</em> or <em>ch_create_pipe</em>.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     TRUE if the channel is asynchronous, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_test_for_connection></a> flag
 <b>ch_test_for_connection</b><i>    (Channel channel)
</i><br><p>    Test if a channel object is a connection channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     TRUE if the channel object is a connection, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_test_for_local_connection></a> flag
 <b>ch_test_for_local_connection</b><i>    (Channel channel)
</i><br><p>    Test if a connection channel object is a local connection.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     TRUE if the channel object is a local connection, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_get_buffer_sizes></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>ch_get_buffer_sizes</b><i>    (Channel channel, uaddr *read_size, uaddr *write_size)
</i><br><p>    Get the read and write buffer sizes for a channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>read_size :</i> 
    The read buffer size is written here.
<br><li><i>write_size :</i> 
    The write buffer size is written here.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE indicating the channel does not have
    read or write buffers.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_set_buffer_sizes></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>ch_set_buffer_sizes</b><i>    (Channel channel, unsigned long read_size,
			  unsigned long write_size)
</i><br><p>    Set the read and write buffer sizes for a channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>read_size :</i> 
    The read buffer size.
<br><li><i>write_size :</i> 
    The write buffer size.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_udp_alloc></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>Channel
 <b>ch_udp_alloc</b><i>    (unsigned int *port_number, flag want_to_read)
</i><br><p>    Create a UDP socket and bind to a random port number.
<p><b>Parameters:</b><ul><li><i>port_number :</i> 
    The port number the socket was bound to.
<br><li><i>port_number :</i> 
    A pointer to the port number to bind to. If the port number
    is 0, a random port number is bound to, and this value is updated with that
    port number.
<br><li><i>want_to_read :</i> 
    If TRUE, a read buffer is created and the channel will be
    readable.
<br></ul><b>Returns:</b>     The channel object on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_set_nodelay></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>ch_set_nodelay</b><i>    (Channel channel)
</i><br><p>    Set the no-delay flag for a channel if appropriate.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_get_qos></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>void
 <b>ch_get_qos</b><i>    (Channel channel, struct karma_qos *qos)
</i><br><p>    Get the Quality of Service parameters for a connection.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>qos :</i> 
    The QoS parameters will be written here.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_register_close_func></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>KCallbackFunc
 <b>ch_register_close_func</b><i>    (Channel channel,
				      void (*func) (), void *info)
</i><br><p>    This routine will register a close function for a channel. This
    is called when <a href=ch.html#ch_close>ch_close</a> is called. Many close functions may be
    registered per channel. The first function registered is the first function
    called upon closure.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>func :</i> 
    The function that is called when the canvas is closed. The
    prototype function is <a href=ch.html#ch_PROTO_close_func>ch_PROTO_close_func</a>.
<br><li><i>info :</i> 
    The arbitrary function information pointer.
<br></ul><b>Returns:</b>     A KCallbackFunc object. On failure, the process aborts.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_close></a> flag
 <b>ch_close</b><i>    (Channel channel)
</i><br><p>    This routine will close a channel object. The write buffer will
    be flushed prior to closure.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_flush></a> flag
 <b>ch_flush</b><i>    (Channel channel)
</i><br><p>    Flush the write buffer of a channel object.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_read></a> uaddr
 <b>ch_read</b><i>    (Channel channel, char *buffer, uaddr length)
</i><br><p>    This routine will read a number of bytes from a channel and
    places them into a buffer.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>buffer :</i> 
    The buffer to write the data into.
<br><li><i>length :</i> 
    The number of bytes to write into the buffer.
<br></ul><b>Returns:</b>     The number of bytes read.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     If the channel is a connection and the number of bytes readable from
    the connection is equal to or more than <em>length</em> the routine will NOT
    block.
</ul><p><hr> <a name=ch_read2></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>uaddr
 <b>ch_read2</b><i>    (Channel channel, char *buffer, CONST char **newbuf,
		unsigned char alignment, uaddr length)
</i><br><p>    This routine will read a number of bytes from a channel and
    places them into a buffer.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>buffer :</i> 
    A suggested buffer to write the data into.
<br><li><i>newbuf :</i> 
    The buffer pointer used is written here. This may be a read-only
    buffer. If this is NULL, the suggested <em>buffer</em> is always used.
<br><li><i>alignment :</i> 
    The number of bytes the buffer must be aligned to.
<br><li><i>length :</i> 
    The number of bytes to write into the buffer.
<br></ul><b>Returns:</b>     The number of bytes read.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     If the channel is a connection and the number of bytes readable from
    the connection is equal to or more than <em>length</em> the routine will NOT
    block.
</ul><p><hr> <a name=ch_write></a> uaddr
 <b>ch_write</b><i>    (Channel channel, CONST char *buffer, uaddr length)
</i><br><p>    This routine will write a number of bytes from a buffer to a
    channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>buffer :</i> 
    The buffer to read the data from.
<br><li><i>length :</i> 
    The number of bytes to read from the buffer and write to the
    channel.
<br></ul><b>Returns:</b>     The number of bytes written.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_close_all_channels></a> void
 <b>ch_close_all_channels</b><i>    ()
</i><br><p>    The routine will close all open channels. The routine is meant to
    be called from the exit(3) function.
<p><b>Parameters:</b><ul>This function takes no parameters<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_seek></a> flag
 <b>ch_seek</b><i>    (Channel channel, unsigned long position)
</i><br><p>    This routine will position the read and write pointers for a
    channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>position :</i> 
    The position (relative to the start of the channel data).
<br></ul><b>Returns:</b>     TRUE on success, else FALSE (indicating a seek request beyond the
    channel limits)
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     This routine cannot be used for connection channels.
</ul><p><hr> <a name=ch_get_bytes_readable></a> int
 <b>ch_get_bytes_readable</b><i>    (Channel channel)
</i><br><p>    This routine will determine the number of bytes currently
    readable on a connection channel. This is equal to the maximum number of
    bytes that could be read from the channel at this time without blocking
    waiting for more input to be transmitted from the other end of the
    connection.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     The number of bytes readable on success, else -1 indicating error
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_test_for_io></a> flag
 <b>ch_test_for_io</b><i>    (Channel channel)
</i><br><p>    This routine will test if a channel object is capable of
    supporting reading and writing operations. Most channels fall under this
    category. The notable exceptions are the dock channel and channels created
    by a call to <em>ch_attach_to_asynchronous_descriptor</em>.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     TRUE if the channel is capable of reading and writing, else FALSE
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_test_for_converters></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>ch_test_for_converters</b><i>    (Channel channel)
</i><br><p>    Test if a channel object has converters.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     TRUE if the channel object is has converters, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_tell></a> flag
 <b>ch_tell</b><i>    (Channel channel, unsigned long *read_pos,
	      unsigned long *write_pos)
</i><br><p>    Get the read and write pointers for a channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>read_pos :</i> 
    The read position (relative to the start of the channel data)
    will be written here.
<br><li><i>write_pos :</i> 
    The write position (relative to the start of the channel data)
    will be written here.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_register_converter></a> ChConverter
 <b>ch_register_converter</b><i>    (Channel channel,
				   unsigned int (*size_func) (),
				   unsigned int (*read_func) (),
				   unsigned int (*write_func) (),
				   flag (*flush_func) (),
				   void (*close_func) (),
				   void *info)
</i><br><p>    This routine will register a set of converter functions which
    will be called when channel data is read or written. The operation of these
    routines is transparent. Converter functions are useful for automatic
    compression and encryption of data streams.
    It is permissable to register multiple converter functions with a channel.
    Converter functions are pushed down from the top (application) level. In
    other words, the last converter functions registered are called first.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>size_func :</i> 
    The function which will determine (approximately) how many
    bytes would be returned by the <em>read_func</em>. This routine is called when
    <a href=ch.html#ch_get_bytes_readable>ch_get_bytes_readable</a> is called for the channel. The prototype function
    is <a href=ch.html#ch_PROTO_converter_size_func>ch_PROTO_converter_size_func</a>.
<br><li><i>read_func :</i> 
    The function which will convert data when reading.
    The prototype function is <a href=ch.html#ch_PROTO_converter_read_func>ch_PROTO_converter_read_func</a>.
<br><li><i>write_func :</i> 
    The function which will convert data when writing. If this is
    NULL, no write conversion is performed. The prototype function is
    <a href=ch.html#ch_PROTO_converter_write_func>ch_PROTO_converter_write_func</a>.
<br><li><i>flush_func :</i> 
    The function which is called when the channel is to be flushed
    The prototype function is <a href=ch.html#ch_PROTO_converter_flush_func>ch_PROTO_converter_flush_func</a>.
<br><li><i>close_func :</i> 
    The function which is called when the channel is closed. If
    this is NULL, no special action is taken upon channel closure.
    The prototype function is <a href=ch.html#ch_PROTO_converter_close_func>ch_PROTO_converter_close_func</a>.
<br></ul><b>Returns:</b>     A ChConverter object on success (which may be used in a call to
    <a href=ch.html#ch_unregister_converter>ch_unregister_converter</a>), else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     Converters impose restrictions on channel operations (i.e.
    <a href=ch.html#ch_seek>ch_seek</a> cannot be called).
<li>     Converter functions are expected to provide their own buffering as
    needed.
<li>     The <em>flush_func</em> will be called prior to the <em>close_func</em> upon
    channel closure.
<li>     
    The sequence of events when the application level calls <a href=ch.html#ch_write>ch_write</a> is:
    The last registered write converter is popped from the stack and called.
    This write converter may buffer some or all of the data. It may call
    <a href=ch.html#ch_write>ch_write</a> with some converted data.
    When <a href=ch.html#ch_write>ch_write</a> is called from a write converter, the next last
    registered write converter is popped from the stack and called.
    This sequence is continued until data is actually transferred into the
    channel write buffer.
    A similar sequence of events occurs when  ch_read  is called.
    The sequence of events when the application level calls  ch_flush  is:
    The last registered flush converter is popped from the stack and called.
    This flush converter MUST write all data in it's buffer using  ch_write
    When  ch_write  is called from a flush converter, the next last
    registered write converter is popped from the stack and called.
    When the last registered flush converter returns, the sequence is
    repeated with the next last flush converter, and so on, until all data
    in all write buffers is flushed, including the channel write buffer.
</ul><p><hr> <a name=ch_unregister_converter></a> void
 <b>ch_unregister_converter</b><i>    (ChConverter converter)
</i><br><p>    This routine will unregister a set of converter functions
    previously registered with <a href=ch.html#ch_register_converter>ch_register_converter</a>. This will cause the
    registered flush and close functions to be called.
<p><b>Parameters:</b><ul><li><i>converter :</i> 
    The ChConverter object.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_tap_io_events></a> KCallbackFunc
 <b>ch_tap_io_events</b><i>    (void (*tap_func) (), void *info)
</i><br><p>    This routine will tap I/O events by calling a registered function
    whenever data is transferred to/from a disc, connection or FIFO channel.
    Reading and writing memory mapped or memory channels does *not* constitute
    an I/O event.
    Multiple tap functions may be registered, with the first one registered
    being the first one called upon a channel I/O event.
<p><b>Parameters:</b><ul><li><i>tap_func :</i> 
    The function which is called when I/O occurs. The prototype
    function is <a href=ch.html#ch_PROTO_tap_func>ch_PROTO_tap_func</a>.
<br><li><i>info :</i> 
    The arbitrary information passed to the tap function. This may be
    NULL.
<br></ul><b>Returns:</b>     A KCallbackFunc. On failure, the process aborts.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_test_valid></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>ch_test_valid</b><i>    (Channel channel, CONST char *function_name)
</i><br><p>    Test if a channel is valid.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>function_name :</i> 
    If not NULL diagnostic messages are written to the standard
    error prepended with <em>function_name</em>.
<br></ul><b>Returns:</b>     TRUE if the channel is valid, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     Frequent use may degrade performance.
</ul><p><hr> <a name=ch_skip></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>ch_skip</b><i>    (Channel channel, uaddr num_bytes)
</i><br><p>    This function will skip a specified number of bytes in a channel,
    jumping to the desired point without reading (if possible). If the channel
    does not support seeking (jumping), then the specified number of bytes are
    read from the channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>num_bytes :</i> 
    The number of bytes to skip.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     Seeking may change the write pointer. Use <a href=ch.html#ch_drain>ch_drain</a> instead if
    the write pointer must be left untouched.
</ul><p><hr> <a name=ch_get_descriptor></a> int
 <b>ch_get_descriptor</b><i>    (Channel channel)
</i><br><p>    Get the file descriptor associated with a channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     The file descriptor on success, else -1 indicating error.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_map_disc></a> Channel
 <b>ch_map_disc</b><i>    (CONST char *filename, unsigned int option, flag writable,
		     flag update_on_write)
</i><br><p>    This routine will open a memory channel with the memory pages
    being mapped from a disc file. The disc file must already exist.
<p><b>Parameters:</b><ul><li><i>filename :</i> 
    The pathname of the file to open.
<br><li><i>option :</i> 
    Control value which determines whether the channel is opened as an
    ordinary disc file or is mapped. See <a href=ch.html#ch_MAP_CONTROLS>ch_MAP_CONTROLS</a> for legal values.
    If the file is not mapped then the routine will attempt to open an ordinary
    disc channel. If the file is opened as a disc channel the access mode is:
    "rz".
<br><li><i>writable :</i> 
    If the mapped pages are to be writable, this must be TRUE. If
    this is FALSE and the memory pages are written to, a segmentation fault
    occurs.
<br><li><i>update_on_write :</i> 
    If the disc file should be updated when the memory pages
    are written to, this must be TRUE. If this is FALSE, then a write to a
    memory page causes the page to be copied into swap space and the process
    retains a private copy of the page from this point on.
<br></ul><b>Returns:</b>     A channel object on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     If <em>update_on_write</em> is FALSE and <em>writable</em> is TRUE, then some
    systems require the allocation of normal virtual memory equal to the size
    of the disc file at the time of mapping, while others will dynamically
    allocate memory from swap space as pages are written into. In the latter
    case, some systems will cause a segmentation fault if swap space is
    exhausted, while other systems wait for space to be freed.
<li>     The channel may be queried to determine if it has been memory mapped
    using the call <em>ch_test_for_mmap</em>.
<li>     If the "CH_MMAP_DISABLE" environment variable is defined, then
    memory mapping is disabled.
</ul><p><hr> <a name=ch_map_fd></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>Channel
 <b>ch_map_fd</b><i>    (int fd, uaddr size, flag writable, flag update_on_write)
</i><br><p>    This routine will open a memory channel with the memory pages
    being mapped from a disc file. The disc file must already exist.
<p><b>Parameters:</b><ul><li><i>fd :</i> 
    The file descriptor to map. This will be closed on error or when the
    channel closes.
<br><li><i>size :</i> 
    The size of the region to map.
<br><li><i>writable :</i> 
    If the mapped pages are to be writable, this must be TRUE. If
    this is FALSE and the memory pages are written to, a segmentation fault
    occurs.
<br><li><i>update_on_write :</i> 
    If the disc file should be updated when the memory pages
    are written to, this must be TRUE. If this is FALSE, then a write to a
    memory page causes the page to be copied into swap space and the process
    retains a private copy of the page from this point on.
<br></ul><b>Returns:</b>     A channel object on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     If <em>update_on_write</em> is FALSE and <em>writable</em> is TRUE, then some
    systems require the allocation of normal virtual memory equal to the size
    of the disc file at the time of mapping, while others will dynamically
    allocate memory from swap space as pages are written into. In the latter
    case, some systems will cause a segmentation fault if swap space is
    exhausted, while other systems wait for space to be freed.
<li>     The channel may be queried to determine if it has been memory mapped
    using the call <em>ch_test_for_mmap</em>.
</ul><p><hr> <a name=ch_open_memory></a> Channel
 <b>ch_open_memory</b><i>    (char *buffer, unsigned int size)
</i><br><p>    This routine will open a memory channel. A memory channel behaves
    like a disc channel with a limited (specified) file (device) size. Data is
    undefined when reading before writing has occurred.
<p><b>Parameters:</b><ul><li><i>buffer :</i> 
    The buffer to use. If this is NULL, the routine will allocate a
    buffer of the specified size which is automatically deallocated upon
    closure of the channel.
<br><li><i>size :</i> 
    The size of the buffer to allocate.
<br></ul><b>Returns:</b>     A channel object on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_test_for_mmap></a> flag
 <b>ch_test_for_mmap</b><i>    (Channel channel)
</i><br><p>    Test if a channel object is a memory mapped disc channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     TRUE if the channel object is memory mapped, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_get_mmap_addr></a> char *
 <b>ch_get_mmap_addr</b><i>    (Channel channel)
</i><br><p>    This routine will get the starting address of the data for a
    memory mapped disc channel. The channel MUST be a memory mapped disc
    channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     The address of the memory mapped data.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     If the memory mapped address space is read-only, any attempt to
    write to this address space will cause a segmentation fault.
</ul><p><hr> <a name=ch_get_memory_addr></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>char *
 <b>ch_get_memory_addr</b><i>    (Channel channel)
</i><br><p>    This routine will get the starting address of the data for a
    memory channel. The channel MUST be a memory mapped disc channel or a
    memory channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     The address of the memory.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     If the memory mapped address space is read-only, any attempt to
    write to this address space will cause a segmentation fault.
</ul><p><hr> <a name=ch_get_mmap_access_count></a> unsigned int
 <b>ch_get_mmap_access_count</b><i>    (Channel channel)
</i><br><p>    This routine will get the number of times a memory mapped disc
    channel has been queried for the mapping address using <em>ch_get_mmap_addr</em>
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     The number of address queries.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The channel MUST be a memory mapped disc channel.
</ul><p><hr> <a name=ch_get_mem_size></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>uaddr
 <b>ch_get_mem_size</b><i>    (Channel channel)
</i><br><p>    Get memory buffer size.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     The number of bytes in the memory channel.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The channel MUST be a memory channel.
</ul><p><hr> <a name=ch_open_and_fill_memory></a> Channel
 <b>ch_open_and_fill_memory</b><i>    (char **strings)
</i><br><p>    This routine will open a memory channel with sufficient space to
    contain a list of strings.
<p><b>Parameters:</b><ul><li><i>strings :</i> 
    The NULL terminated array of string pointers.
    The strings are written with a NEWLINE character to terminate the string.
    The NULL terminator character is not written.
<br></ul><b>Returns:</b>     A channel object on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_gets></a> flag
 <b>ch_gets</b><i>    (Channel channel, char *buffer, unsigned int length)
</i><br><p>    This routine will read a character string from a channel into a
    buffer.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>buffer :</i> 
    The buffer to write the data into.
    The routine will write a NULL terminator character at the end of the
    string.
<br><li><i>length :</i> 
    The length of the buffer. If the buffer is not large enough to
    contain the string, then the remainder of the string is NOT read. See also
    the <a href=ch.html#ch_getl>ch_getl</a> routine.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE (indicating end-of-file was
    encountered). Data is still written to the buffer and NULL terminated on
    EOF.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The newline chanacter '\n' is NOT copied into the buffer.
</ul><p><hr> <a name=ch_getl></a> flag
 <b>ch_getl</b><i>    (Channel channel, char *buffer, unsigned int length)
</i><br><p>    This routine will read a character string from a channel into a
    buffer.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>buffer :</i> 
    The buffer to write the data into.
    The routine will write a NULL terminator character at the end of the
    string.
<br><li><i>length :</i> 
    The length of the buffer. If the buffer is not large enough to
    contain the string, then the remainder of the string (including the
    newline character) is read in and discarded and a warning message is
    displayed. See also the <a href=ch.html#ch_gets>ch_gets</a> routine.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE (indicating end-of-file was
    encountered). Data is still written to the buffer and NULL terminated on
    EOF.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The newline chanacter '\n' is NOT copied into the buffer.
</ul><p><hr> <a name=ch_puts></a> flag
 <b>ch_puts</b><i>    (Channel channel, CONST char *string, flag newline)
</i><br><p>    Write a character string to a channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>string :</i> 
    The string.
<br><li><i>newline :</i> 
    If TRUE, the routine will write a NEWLINE character after writing
    the string.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The routine will not write the NULL terminator character.
</ul><p><hr> <a name=ch_drain></a> unsigned int
 <b>ch_drain</b><i>    (Channel channel, unsigned int length)
</i><br><p>    This routine will drain (read) a specified number of bytes from a
    channel, ignoring the data.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The Channel object.
<br><li><i>length :</i> 
    The number of bytes to drain.
<br></ul><b>Returns:</b>     The number of bytes drained.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_fill></a> unsigned int
 <b>ch_fill</b><i>    (Channel channel, unsigned int length, char fill_value)
</i><br><p>    This routine will write a specified byte to a channel a number of
    times.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The Channel object.
<br><li><i>length :</i> 
    The number of bytes to write.
<br><li><i>fill_value :</i> 
    The fill value.
<br></ul><b>Returns:</b>     The number of bytes written.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_printf></a> flag
 <b>ch_printf</b><i>    (Channel channel, CONST char *format, ...)
</i><br><p>    Write formatted output to a channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>format :</i> 
    The format string. See <em>fprintf</em>.
<br><li><i>... :</i> 
    The optional parameters. See <em>fprintf</em>.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_scanf></a> int
 <b>ch_scanf</b><i>    (Channel channel, CONST char *format, ...)
</i><br><p>    Read formatted input from a channel.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>format :</i> 
    The format string. See <em>fscanf</em>.
<br><li><i>... :</i> 
    The optional parameters. See <em>fscanf</em>.
<br></ul><b>Returns:</b>     The number of objects scanned.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     This function requires the standard C library <em>vsscanf</em> function,
    which is not supported under Solaris 2.
<li>     This function will internally read a line at a time. Beware.
</ul><p><hr> <a name=ch_drain_to_boundary></a> flag
 <b>ch_drain_to_boundary</b><i>    (Channel channel, uaddr size)
</i><br><p>    This routine will drain (read) from a channel until the current
    read position is aligned with a boundary.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The Channel object.
<br><li><i>size :</i> 
    The size to align to.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_skip_to_boundary></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>ch_skip_to_boundary</b><i>    (Channel channel, uaddr size)
</i><br><p>    This routine will skip bytes in a channel until the current
    read position is aligned with a boundary.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The Channel object.
<br><li><i>size :</i> 
    The size to align to.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     This may change the write pointer. Use <a href=ch.html#ch_drain_to_boundary>ch_drain_to_boundary</a>
    instead if the write pointer must be left untouched.
</ul><p><hr> <a name=ch_fill_to_boundary></a> flag
 <b>ch_fill_to_boundary</b><i>    (Channel channel, uaddr size, char fill_value)
</i><br><p>    This routine will write bytes to a channel until the current
    write position is aligned with a boundary.
    channel, ignoring the data.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The Channel object.
<br><li><i>size :</i> 
    The size to align to.
<br><li><i>fill_value :</i> 
    The value to fill with.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_read_and_swap_blocks></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>uaddr
 <b>ch_read_and_swap_blocks</b><i>    (Channel channel, char *buffer,
			       uaddr num_blocks, uaddr block_size)
</i><br><p>    This routine will read a number of blocks from a channel and
    places them into a buffer after swapping (reversing the order).
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>buffer :</i> 
    The buffer to write the data into.
<br><li><i>num_blocks :</i> 
    The number of blocks to read.
<br><li><i>block_size :</i> 
    The size (in bytes) of each block.
<br></ul><b>Returns:</b>     The number of bytes read. Errors may cause partial blocks to be
    read.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     If the channel is a connection and the number of bytes readable from
    the connection is equal to or more than <em>num_blocks * block_size</em> the
    routine will NOT block.
</ul><p><hr> <a name=ch_swap_and_write_blocks></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>uaddr
 <b>ch_swap_and_write_blocks</b><i>    (Channel channel, CONST char *buffer,
				uaddr num_blocks, uaddr block_size)
</i><br><p>    This routine will write a number of blocks to a channel after
    swapping the bytes.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>buffer :</i> 
    The buffer to read the data from.
<br><li><i>num_blocks :</i> 
    The number of blocks to write.
<br><li><i>block_size :</i> 
    The size (in bytes) of each block.
<br></ul><b>Returns:</b>     The number of bytes written. Errors may cause partial blocks to
    be written.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_copy></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>uaddr
 <b>ch_copy</b><i>    (Channel out, Channel in, uaddr num_bytes)
</i><br><p>    Copy bytes from one channel to another in an optimal way.
<p><b>Parameters:</b><ul><li><i>out :</i> 
    The output channel.
<br><li><i>in :</i> 
    The input channel.
<br><li><i>num_bytes :</i> 
    The number of bytes to copy. If this is 0, the remaining unread
    contents of <em>in</em> are copied.
<br></ul><b>Returns:</b>     The number of bytes copied. On error a message is generated and
    the number of bytes successfully copied is returned.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_map_disc2></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>Channel
 <b>ch_map_disc2</b><i>    (CONST char *filename, unsigned int option)
</i><br><p>    This routine will attempt to open a memory channel with the
    memory pages being mapped from a disc file. The disc file must already
    exist. If memory mapping cannot be performed, a normal memory channel is
    created and the data is read in.
<p><b>Parameters:</b><ul><li><i>filename :</i> 
    The pathname of the file to open.
<br><li><i>option :</i> 
    Control value which determines whether the channel is opened as an
    ordinary disc file or is mapped. See <a href=ch.html#ch_MAP_CONTROLS>ch_MAP_CONTROLS</a> for legal values.
    If the file is not mapped then the routine will attempt to open an ordinary
    disc channel. If the file is opened as a disc channel the access mode is:
    "rz".
<br></ul><b>Returns:</b>     A channel object on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><b>Note:</b><ul> <li>     The channel may be queried to determine if it has been memory mapped
    using the call <em>ch_test_for_mmap</em>.
<li>     If the "CH_MMAP_DISABLE" environment variable is defined, then
    memory mapping is disabled.
<li>     Writing to the memory may cause a segmentation fault.
</ul><p><hr> <a name=ch_open_compressed_file></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>Channel
 <b>ch_open_compressed_file</b><i>    (CONST char *filename)
</i><br><p>    This routine will open a file channel for reading, automatically
    decompressing data as it is needed. Alternative filenames may be opened
    in an attempt to file a compressed variant of the base filename.
<p><b>Parameters:</b><ul><li><i>filename :</i> 
    The base pathname of the file to open.
<br></ul><b>Returns:</b>     A channel object on success, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_get_bytes_remaining_in_disc></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>flag
 <b>ch_get_bytes_remaining_in_disc</b><i>    (Channel channel, uaddr *length)
</i><br><p>    Return the number of bytes remaining in a disc file.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel to test.
<br><li><i>length :</i> 
    The number of bytes readable is written here.
<br></ul><b>Returns:</b>     TRUE on success, else FALSE indicating a non-disc channel or a
    converter is registered.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_create_sink></a> Channel
 <b>ch_create_sink</b><i>    ()
</i><br><p>    This routine will create a data sink channel. All writes to the
    channel are discarded (and reported as having succeeded) and all reads
    return an End-Of-File condition. Read and write operations modify the
    absolute read and write pointers (obtainable with <a href=ch.html#ch_tell>ch_tell</a>) as expected.
<p><b>Parameters:</b><ul>This function takes no parameters<br></ul><b>Returns:</b>     The channel object on succes, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_create_zero></a> <font color="cc0000"><h4>EXPERIMENTAL FUNCTION: subject to change without notice</h4></font>Channel
 <b>ch_create_zero</b><i>    ()
</i><br><p>    This routine will create a data source channel. All reads from
    the channel will yield values of zero. Write operations fail.
<p><b>Parameters:</b><ul>This function takes no parameters<br></ul><b>Returns:</b>     The channel object on succes, else NULL.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr><center><h2>Prototype Functions</h2></center><hr> <a name=ch_PROTO_converter_size_func></a> unsigned int
 <b>ch_PROTO_converter_size_func</b><i>    (Channel channel, void **info)
</i><br><p>    This routine will determine the approximate number of bytes that
    the <em>read_func</em> will return.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object.
<br><li><i>info :</i> 
    A pointer to the arbitrary information pointer. This may be modified
<br></ul><b>Returns:</b>     The number of bytes the <em>read_func</em> will return.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_PROTO_converter_read_func></a> unsigned int
 <b>ch_PROTO_converter_read_func</b><i>    (Channel channel, char *buffer,
					   unsigned int length, void **info)
</i><br><p>    This routine will convert bytes being read from a channel object.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object. It is permissable for the routine to call
    <a href=ch.html#ch_read>ch_read</a> with this channel. If this is done, this function will be
    bypassed.
<br><li><i>buffer :</i> 
    The buffer to write the data into.
<br><li><i>length :</i> 
    The number of bytes to write into the buffer.
<br><li><i>info :</i> 
    A pointer to the arbitrary information pointer. This may be modified
<br></ul><b>Returns:</b>     The number of bytes actually written to the buffer.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_PROTO_converter_write_func></a> unsigned int
 <b>ch_PROTO_converter_write_func</b><i>    (Channel channel, char *buffer,
					    unsigned int length, void **info)
</i><br><p>    This routine will convert bytes being written to a channel object
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object. It is permissable for the routine to call
    <a href=ch.html#ch_write>ch_write</a> with this channel. If this is done, this function will be
    bypassed.
<br><li><i>buffer :</i> 
    The buffer to read the data from. The contents of this buffer may
    be modified if needed.
<br><li><i>length :</i> 
    The number of bytes to read from the buffer.
<br><li><i>info :</i> 
    A pointer to the arbitrary information pointer. This may be modified
<br></ul><b>Returns:</b>     The number of bytes read from the buffer.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_PROTO_converter_flush_func></a> flag
 <b>ch_PROTO_converter_flush_func</b><i>    (Channel channel, void **info)
</i><br><p>    This routine will process a flush request for a channel object.
<p><b>Parameters:</b><ul><li><i>channel :</i> 
    The channel object. It is permissable for the routine to call
    <a href=ch.html#ch_flush>ch_flush</a> with this channel. If this is done, this function will be
    bypassed.
<br><li><i>info :</i> 
    A pointer to the arbitrary information pointer. This may be modified
<br></ul><b>Returns:</b>     TRUE on success, else FALSE.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_PROTO_converter_close_func></a> void
 <b>ch_PROTO_converter_close_func</b><i>    (void *info, Channel channel)
</i><br><p>    This routine is called when a channel is closed.
<p><b>Parameters:</b><ul><li><i>info :</i> 
    The arbitrary information pointer.
<br><li><i>channel :</i> 
    The channel object.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_PROTO_tap_func></a> void
 <b>ch_PROTO_tap_func</b><i>    (void *info)
</i><br><p>    This routine is called when I/O occurs.
<p><b>Parameters:</b><ul><li><i>info :</i> 
    The arbitrary information pointer.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr> <a name=ch_PROTO_close_func></a> flag
 <b>ch_PROTO_close_func</b><i>    (void *info)
</i><br><p>    Process a destroy event for an object.
<p><b>Parameters:</b><ul><li><i>info :</i> 
    An arbitrary function information pointer.
<br></ul><b>Returns:</b>     Nothing.
<br><b>Multithreading Level:</b> Unsafe<br><p><hr><center><h2>Tables</h2></center><hr> <a name=ch_FILE_MODES><b>ch_FILE_MODES</b></a> List of defined file modes
<p> <table><tr><td>Mode         </td><td>Meaning
</td></tr><tr><td>
</td></tr><tr><td>"r"          </td><td>open for reading
</td></tr><tr><td>"w"          </td><td>open (truncate) or create for writing
</td></tr><tr><td>"a"          </td><td>open or create for writing at end of file (append)
</td></tr><tr><td>"r+"         </td><td>open for update (reading and writing)
</td></tr><tr><td>"w+"         </td><td>open for reading and writing after truncation
</td></tr><tr><td>"a+"         </td><td>open or create for update (reading and writing) at EOF
</td></tr><tr><td>"W"          </td><td>open for writing
</td></tr><tr><td>"s"          </td><td>like "w", but create holes when writing zero blocks
</td></tr><tr><td>"t"          </td><td>set the sticky bit
</td></tr><tr><td>"z"          </td><td>uncompress if file was compressed (has ".gz" extension)
</td></tr><tr><td>"l"          </td><td>lock the file, fail if lock not grabbed, unlock on close
</td></tr><tr><td>"L"          </td><td>lock the file, waiting for lock, unlock on close
</table><p><hr> <a name=ch_MAP_CONTROLS><b>ch_MAP_CONTROLS</b></a> List of mapping control values
<p> <table><tr><td>Control                      </td><td>Meaning
</td></tr><tr><td>
</td></tr><tr><td>K_CH_MAP_NEVER               </td><td>Never map
</td></tr><tr><td>K_CH_MAP_LARGE_LOCAL         </td><td>Map if local filesystem and file size > 1MB
</td></tr><tr><td>K_CH_MAP_LOCAL               </td><td>Map if local filesystem
</td></tr><tr><td>K_CH_MAP_LARGE               </td><td>Map if file over 1 MByte
</td></tr><tr><td>K_CH_MAP_IF_AVAILABLE        </td><td>Map if operating system supports it
</td></tr><tr><td>K_CH_MAP_ALWAYS              </td><td>Always map, fail if not supported.
</table><p><hr> <a name=ch_ENVIRONMENT><b>ch_ENVIRONMENT</b></a> List of environment variables
<p> <table><tr><td>Variable                     </td><td>Meaning
</td></tr><tr><td>
</td></tr><tr><td>CH_MMAP_DISABLE              </td><td>Disable memory mapping
</table><p>
<hr><a href="../index.html">Back to Karma Home Page</a>
<hr><center><address>Contact: <a href="http://www.atnf.csiro.au/~rgooch/">Richard Gooch</a><br>Web Development: <a href="http://www.ariel.com.au/">Ariel Internet Services</a></address></center></body></html>
